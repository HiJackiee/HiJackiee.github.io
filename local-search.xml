<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（四）</title>
    <link href="/2024/12/28/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_4/"/>
    <url>/2024/12/28/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_4/</url>
    
    <content type="html"><![CDATA[<h2 id="预定义宏⌊Predefined-Macros⌉">预定义宏⌊Predefined Macros⌉</h2><p>  一些<strong>类对象宏</strong><code>object-like Macros</code>是预定义的，使用它们时不需要提供它们的定义。它们分为三类: <code>标准宏⌊Standard Macros⌉</code>、<code>通用宏⌊Common Macros⌉</code>和<code>系统特定宏⌊System-specific Macros⌉</code>。</p><p>  在 <code>C++</code> 中，还有第四类：<code>命名操作符⌊Named operators⌉</code>。它们就像预定义的宏，但是不能被取消定义（<code>undefine</code>）。</p><h3 id="标准预定义宏⌊Standard-Predefined-Macros⌉">标准预定义宏⌊Standard Predefined Macros⌉</h3><p>  标准的预定义宏是由相关的语言标准指定的，因此它们可用于实现这些标准的所有编译器。旧的编译器可能不会提供所有这些选项。这类预定义宏的名字<u>都以双下划线开头</u>。例如：</p><h4 id="1-FILE-宏">1. __FILE__宏</h4><p>  <code>__FILE__</code>宏以<code>C</code><strong>字符串的名称常量</strong>的形式展开。这是预处理器打开文件的路径，而不是<code>#include</code>中指定的短名称或作为输入的文件名参数。例如，<code>/usr/local/include/myheade.h</code>是<code>__FILE__</code>宏可能的扩展结果。</p><h4 id="2-LINE-宏">2. __LINE__宏</h4><p>  <code>__LINE__</code>宏将以<strong>十进制整数常数</strong>的形式扩展到当前的输入行数。虽然我们称之为预定义的宏，但它是一个相当奇怪的宏，因为它的“定义”会随着每一个新的源代码行而变化。</p><br><p>  <code>__FILE__</code> 和 <code>__LINE__</code> 对于生成消息来报告程序检测到的错误非常有用; 消息可以报告检测到错误的源代码的行数。比如说：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">fprintf</span> (stderr, <span class="hljs-string">&quot;Internal error: &quot;</span><br>               <span class="hljs-string">&quot;negative string length &quot;</span><br>               <span class="hljs-string">&quot;%d at %s, line %d.&quot;</span>,<br>       length, __FILE__, __LINE__);<br></code></pre></td></tr></table></figure><p>  对于 <code>__FILE__</code> 和 <code>__LINE__</code> 宏遇到 <code>#include</code> 预处理指令时其展开会有变化。当编译器遇到 <code>#include</code> 指令时，它会将当前的输入流替换为被包含文件的内容。在这个过程中，预处理器会改变 <code>__FILE__</code> 和 <code>__LINE__</code> 宏的展开值，使它们分别对应于被包含文件的名称和行号。也即是说：</p><ul><li><code>__FILE__</code> 宏会展开为被包含文件的文件名字符串；</li><li><code>__LINE__</code> 宏会展开为被包含文件对应位置的行号。</li></ul><p>  当包含文件结束，即 <code>#include</code> 指令结束，编译器回到包含 <code>#include</code> 指令的原文件继续处理，<code>__FILE__</code> 和 <code>__LINE__</code> 的值会恢复到 <code>#include</code> 指令之前的值。但是需要注意的是，<code>__LINE__</code> 的值会增加 <code>1</code>，因为<code>#include</code> 指令已经执行完成，当前是 <code>#include</code> 指令的下一行。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;header.h&quot;</span></span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Back in main.cpp, line: &quot;</span> &lt;&lt; __LINE__ &lt;&lt; std::endl;   <span class="hljs-comment">// 此处 __LINE__ 值为 3</span><br><br><span class="hljs-comment">// header.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_INFO() std::cout \</span><br><span class="hljs-meta">    &lt;&lt; <span class="hljs-string">&quot;In header.h, file: &quot;</span>   \</span><br><span class="hljs-meta">    &lt;&lt; __FILE__ &lt;&lt; <span class="hljs-string">&quot;, line: &quot;</span>  \</span><br><span class="hljs-meta">    &lt;&lt; __LINE__ &lt;&lt; std::endl</span><br><br><span class="hljs-built_in">PRINT_INFO</span>();<br></code></pre></td></tr></table></figure><p>  当 <code>__LINE__</code> 和 <code>__FILE__</code> 遇到 <code>#line</code> 指令时同样有所变化，这里不做讨论。</p><blockquote><p>  <code>C99</code>引入了 <code>__func__</code>,<code>GCC</code>长期以来一直提供 <code>__FUNCION__</code>。这两个字符串都包含当前函数的名称(两者在语义上略有不同; 请参阅 <code>GCC</code> 手册)。它们<strong>都不是宏</strong>; 预处理器不知道当前函数的名称。但是，它们往往与 <code>__FILE__</code> 和 <code>__LINE__</code> 结合使用。</p></blockquote><h4 id="3-宏">3. ____宏</h4>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>C</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程之层次锁</title>
    <link href="/2024/12/26/Concurrency/c++%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B1%82%E6%AC%A1%E9%94%81/"/>
    <url>/2024/12/26/Concurrency/c++%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B1%82%E6%AC%A1%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="层次锁⌊hierarchical-lock⌉">层次锁⌊hierarchical lock⌉</h2><p>  在<code>C++</code>多线程编程中，避免死锁是一大要务。简单回顾一下死锁的概念：</p><h3 id="死锁">死锁</h3><p>  死锁（<code>Deadlock</code>）多线程执行过程中，每个线程都持有一些资源，同时又尝试获取其他线程所持有的资源，导致所有线程都无法继续执行的一种状态。简单理解，就是多个线程相互等待对方释放资源，但没有任何线程能够继续向前推进。</p><p>  死锁通常涉及四个基本条件：</p><ol><li><p>互斥<br>指资源在某一时刻只能被一个线程使用，如多线程编程中常见的互斥元 <code>mutex</code>；</p></li><li><p>占有和等待<br>指一个线程至少占有一个资源，同时又等待获取其他线程占有的资源；</p></li><li><p>不可抢占<br>指资源只能由占有它的线程资源释放，而不能强行剥夺；</p></li><li><p>循环等待<br>指存在一个线程的集合，其中每个线程都在等待下一个线程所占有的资源，形成一个等待的循环。</p></li></ol><h3 id="避免死锁">避免死锁</h3><p>  避免死锁的方法有很多，基本思路就是破坏死锁发生的四个基本条件：</p><ol><li><p>破坏互斥条件<br>即允许资源同时被多个线程访问，但这通常并不适合需要互斥访问的资源；</p></li><li><p>破坏占有与等待条件<br>要求线程在请求新资源之前释放所有已占有的资源；</p></li><li><p>破坏不可抢占条件<br>允许资源被抢占，在实践中这很难实现；</p></li><li><p>破坏循环等待条件<br>通过给所有资源（如互斥元）编号一个顺序，并要求线程按照这个顺序请求资源；</p></li></ol><p>  我们这里讨论破坏循环等待条件的情况，即为所有资源编号一个顺序，使得所有线程只能按照固定的顺序请求资源。下面的“资源”统一以互斥元（<code>mutex</code>）为例。</p><h4 id="以固定顺序获取锁">以固定顺序获取锁</h4><p>  相当直观的一个事实：当死锁发生时，必须存在一个线程之间的等待循环，每个线程都在等待下一个线程释放资源。如果存在两个或者更多的互斥元，<code>C++17</code> 引入了 <code>std::lock</code> 的方法来<strong>原子性</strong>地锁定多个互斥元，也即是说<u>要么同时锁定多个互斥元，要么阻塞当前线程直到所有的互斥元都可用</u>。这是可以考虑地一种方法，但是当不能使用 <code>std::lock</code> 的单个操作取得多个锁时，次优的做法就是在每个线程中以相同的顺序获取互斥元，也就是破坏循环等待条件。</p><p>  很好理解的是，这里的<code>顺序</code>是一种全局的顺序，而非相对的。什么意思，比如，一个函数的参数列表中传入两个互斥元，我们以一种相对的顺序：先锁第一个参数，再锁第二个参数，此时就是一种相对的而非全局的顺序。很显然，这样的相对锁定顺序同样会引起死锁的发生——当线程 <code>A</code> 和线程 <code>B</code> 的参数顺序恰好相反时，这就是一个典型的死锁。</p><p>  如何实现一种全局的顺序呢？下面介绍的<strong>层次锁</strong>将是一个不错的方法。</p><h3 id="使用层次锁">使用层次锁</h3><p>  你可以称之为 <code>层次锁⌊hierarchical lock⌉</code>、<code>层次互斥元⌊hierarchical_mutex⌉</code>（<code>hierarchical adj 分等级的</code>） 等等，一切都是接受的，这并非关键。<strong>层次锁</strong>并未在 <code>C++</code> 标准中得到实现，而是一种用户自定义的互斥锁，这很有用，兴许不久的将来会看到它会进入到 <code>C++</code> 标准中。层次锁实际上是定义了互斥元的锁定顺序的特例，并在实际运行中检查是否遵循这种<code>顺序</code>。</p><p>  <code>hierarchical_mutex</code> 的工作原理基于一个简单的规则：在同一线程中，只能按照层次值递减的顺序锁定多个 <code>hierarchical_mutex</code>。这实际上就体现了锁定的固定顺序：即从<u>高到低的顺序</u>。如果尝试违反这一规则的顺序锁定互斥元，<code>hierarchical_mutex</code> 会抛出异常，表明层次被违反。这里需要注意的是：如果锁在层次中处于相同级别，则不能同时持有它们。</p><blockquote><p>那么实现细节？</p></blockquote><p>  一个自定义的 <code>hierarchical_mutex</code> 类通常包含以下几个部分：</p><ol><li>一个内部的 <code>std::mutex</code> 用于实际的互斥；</li><li>一个 <code>hierarchical_value</code> 用于存储该互斥锁的层次值；</li><li>一个 <code>previous_hierarchy_value</code> 用于存储当前线程的前一个层次值；</li><li>一个 <code>this_thread_hierarchy_value</code> 的静态局部变量，用于跟踪当前线程的层次值。</li></ol><p>  当然，为了支持 <code>std::lock_guard</code> 的 <code>RAII</code> 惯用语法，<code>hierarchical_mutex</code> 类提供了 <code>lock</code>、<code>unlock</code> 和 <code>try_lock</code> 等成员函数，以支持互斥锁的基本操作，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(hierarchical_mutex(<span class="hljs-number">5000</span> <span class="hljs-comment">/*层次值*/</span>))</span></span><br></code></pre></td></tr></table></figure><blockquote><p><code>try_lock()</code> 成员函数用于尝试锁定一个互斥元，若互斥元的锁已经为另一个线程所持有，则返回 <code>false</code></p></blockquote><p>下面是 <code>hierarchical_mutex</code> 的简单实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">hierarchical_mutex</span>&#123;<br>    std::mutex internal_mutex;  <span class="hljs-comment">// 用于实际的互斥</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">const</span> hierarchy_value;    <span class="hljs-comment">// 存储该互斥锁的层次值</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> previous_hierarchy_value;   <span class="hljs-comment">// 存储当前线程的前一个层次值</span><br>                                              <span class="hljs-comment">// 互斥元解锁时恢复层次值</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">thread_local</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> this_thread_hierarchy_value;  <br>            <span class="hljs-comment">// thread_local 用于声明一个局部于线程的静态变量，这意味着每个线程都会拥有该</span><br>            <span class="hljs-comment">// 变量的独立副本。这类变量称为线程局部存储（Thread-Local Storge, TLS）</span><br>            <span class="hljs-comment">// 生命周期是始于线程创建，终于线程结束</span><br><br>            <span class="hljs-comment">// this_thread_hierarchy_value 用于跟踪当前线程的层次值</span><br><br>    <span class="hljs-comment">// 规则检查</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_for_hierarchy_violation</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 锁定顺序应该是由高到低，当前线程只能锁定层次值低于自身的互斥元</span><br>        <span class="hljs-keyword">if</span> (this_thread_hierarchy_value &lt;= hierarchy_value)&#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;mutex hierarchy violated&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新层次值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_hierarchy_value</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 保存当前线程层次值到 previous_hierarchy_value</span><br>        previous_hierarchy_value = this_thread_hierarchy_value;<br><br>        <span class="hljs-comment">// 锁定一个互斥元后将线程的层次值更新为互斥元对应的层次值</span><br>        this_thread_hierarchy_value = hierarchy_value;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数，接受一个 unsigned long 类型的层次值</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">hierarchical_mutex</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> value)</span>: hierarchy_value(value),</span><br><span class="hljs-function">            previous_hierarchy_value(<span class="hljs-number">0</span>) &#123;</span>&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">check_for_hierarchy_violation</span>();<br>        internal_mutex.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-built_in">update_hierarchy_value</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 恢复当前线程的层次值为 previous_hierarchy_value</span><br>        this_thread_hierarchy_value = previous_hierarchy_value;<br>        internal_mutex.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">check_for_hierarchy_violation</span>();<br>        <span class="hljs-keyword">if</span> (!internal_mutex.<span class="hljs-built_in">try_lock</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-built_in">update_hierarchy_value</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// this_thread_hierarchy_value 设置为 ULONG_MAX，即初始化为最大值，目的就是使其初始时可</span><br><span class="hljs-comment">// 以锁定任何层次值的互斥元，选取哪一层次的锁作为开始总是自由的</span><br><span class="hljs-function"><span class="hljs-keyword">thread_local</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> </span><br><span class="hljs-function">    <span class="hljs-title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="hljs-params">(ULONG_MAX)</span></span>;<br></code></pre></td></tr></table></figure><p>  下面以一个实际例子来讲解 <code>hierarchical_mutex</code> 的作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">hierarchical_mutex <span class="hljs-title">high_level_mutex</span><span class="hljs-params">(<span class="hljs-number">10000</span>)</span></span>; <span class="hljs-comment">// 定义一个高层次值的层次互斥元</span><br><span class="hljs-function">hierarchical_mutex <span class="hljs-title">low_level_mutex</span><span class="hljs-params">(<span class="hljs-number">5000</span>)</span></span>;   <span class="hljs-comment">// 定义一个低层次值的层次互斥元</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">do_low_level_stuff</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">low_level_func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(low_level_mutex)</span></span>; <span class="hljs-comment">// RAII 语法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">do_low_level_stuff</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">high_level_stuff</span><span class="hljs-params">(<span class="hljs-type">int</span> some_param)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">high_level_func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(high_level_mutex)</span></span>;<br>    <span class="hljs-built_in">high_level_stuff</span>(<span class="hljs-built_in">low_level_func</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_a</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">high_level_func</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是整个代码函数依赖图：</p><pre><code class=" mermaid">graph TD    threadA[&quot;thread_a()&quot;]    highLevelFunc[&quot;high_level_func()&quot;]    lowLevelFunc[&quot;low_level_func()&quot;]    doLowLevelStuff[&quot;do_low_level_stuff()&quot;]    highLevelStuff[&quot;high_level_stuff()&quot;]    threadA --&gt; highLevelFunc    highLevelFunc --&gt; lowLevelFunc    highLevelFunc --&gt; highLevelStuff    lowLevelFunc --&gt; doLowLevelStuff</code></pre><p><img src="/img/in_posts/Concurrency/%E5%B1%82%E6%AC%A1%E9%94%81%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%9B%BE1.png" alt="函数依赖图1"></p><p>  假设线程<code>a</code> 执行 <code>thread_a</code> 函数，初始时，线程 <code>a</code> 的<code>this_thread_hierarchy_value</code> 为 <code>ULONG_MAX</code>，即最大值。之后，<code>thread_a()</code> 调用 <code>high_level_func()</code>，并锁定了 <code>high_level_mutex</code>（具有层次值为 <code>10000</code>），使得线程 <code>a</code> 的 <code>this_thread_hierarchy_value</code> 值更新为当前层次互斥元的层次值 <code>10000</code>。然后在 <code>high_level_func()</code> 中调用了 <code>low_level_func()</code>，并锁定了 <code>low_level_mutex</code>（具有层次值为 <code>5000</code>），此时线程 <code>a</code> 的 <code>this_thread_hierarchy_value</code> 值更新为当前层次互斥元的层次值 <code>5000</code>。所有，线程 <code>a</code> 对层次互斥元的锁定符合由高到低的顺序，因此运行良好。</p><p>  来看运行失败的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">hierarchical_mutex <span class="hljs-title">other_mutex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_other_stuff</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">other_stuff</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">high_level_func</span>();<br>    <span class="hljs-built_in">do_other_stuff</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_b</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(other_mutex)</span></span>;<br>    <span class="hljs-built_in">other_stuff</span>();<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TD    threadB[&quot;thread_b()&quot;]    otherStuff[&quot;other_stuff()&quot;]    highLevelFunc[&quot;high_level_func()&quot;]    lowLevelFunc[&quot;low_level_func()&quot;]    doLowLevelStuff[&quot;do_low_level_stuff()&quot;]    highLevelStuff[&quot;high_level_stuff()&quot;]    doOtherStuff[&quot;do_other_stuff()&quot;]    threadB --&gt; otherStuff    otherStuff --&gt; highLevelFunc    otherStuff --&gt; doOtherStuff    highLevelFunc --&gt; lowLevelFunc    highLevelFunc --&gt; highLevelStuff    lowLevelFunc --&gt; doLowLevelStuff</code></pre><p><img src="/img/in_posts/Concurrency/%E5%B1%82%E6%AC%A1%E9%94%81%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%9B%BE2.png" alt="函数依赖图2"></p><p>  线程 <code>b</code> 执行 <code>thread_b</code> 函数，初始时，线程 <code>b</code> 的<code>this_thread_hierarchy_value</code> 同样为 <code>ULONG_MAX</code>，即最大值。之后，<code>thread_b()</code> 经过了 <code>check_for_hierarchy_violation()</code> 的检查并锁定了 <code>other_mutex</code>（层次值为 <code>100</code>），使得线程 <code>b</code> 的 <code>this_thread_hierarchy_value</code> 值更新为当前层次互斥元的层次值 <code>100</code>。之后 <code>thread_b()</code> 又调用了 <code>other_stuff()</code>，其内部调用了 <code>high_level_func()</code>,而 <code>high_level_func()</code> 尝试锁定具有更高层次值的 <code>high_level_mutex</code>（层次值为 <code>10000</code>），在进行 <code>check_for_hierarchy_violation()</code> 抛出了异常，线程 <code>b</code> 运行失败。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（三）</title>
    <link href="/2024/12/24/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_3/"/>
    <url>/2024/12/24/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_3/</url>
    
    <content type="html"><![CDATA[<h2 id="连接-Concatenation">连接[Concatenation]</h2><p>  在拓展宏时，将两个标记合并成一个标记通常很有用。而这个过程被称为<strong>标记连接</strong> <code>token concatenation</code>（或称<strong>标记粘贴</strong> <code>token pasting</code>），这是通过 <code>##</code>预处理运算符实现的。宏进行展开时，在<code>##</code>运算符两侧的标记会被合并成为一个标记，而<code>##</code>运算符本身会被删去。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE(x, y) x ## y</span><br><br><span class="hljs-built_in">PASTE</span>(My, Class)<br><br><span class="hljs-comment">// 预处理之后</span><br>MyClass<br></code></pre></td></tr></table></figure><h3 id="合法的标记">合法的标记</h3><p>  那么 <code>##</code> 两侧可以放置的合法的标记有哪些呢？一下是一些合法的标记：</p><ol><li>标识符（<code>Identifiers</code>）：合法的 <code>C/C++</code> 标识符，例如变量名、函数名等；</li><li>预处理数字（<code>Preprocessing Numbers</code>）：预处理器识别的数字，包括整数和浮点数；</li><li>字符串字面量（<code>String Literals</code>）：用双引号括起来的字符串；</li><li>宏参数（<code>Macro Parameters</code>）：宏定义中使用的参数；</li><li>宏（<code>Macros</code>）：已经定义过的宏；</li><li>关键字（<code>Keywords</code>）：<code>C\C++</code> 中的关键字，比如 <code>int</code>、<code>if</code>等；</li><li>操作符和分隔符（<code>Operators and Separators</code>）：如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>等；</li><li>空标记（<code>Empty Tokens</code>）：在某些情况下，空标记也是合法的，例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONCAT(a, b) a ## b</span><br><span class="hljs-built_in">CONCAT</span>(, foo)<br><br><span class="hljs-comment">// 预处理展开后：</span><br>foo<br></code></pre></td></tr></table></figure></li><li>多字符操作符（<code>Multi-Character Operators</code>）：例如 <code>+=</code>、<code>-&gt;</code> 等；</li></ol><blockquote><p>并非所有的标记都可以使用 <code>##</code> 操作符进行连接。如果两个标记连接后不能形成一个有效的标记，那么预处理器将不会尝试将它们合并，而是会发出警告，并输出这两个标记。这里的有效的标记就是上面罗列的合法的标记。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONCAT(a, b) a ## b</span><br><span class="hljs-built_in">CONCAT</span>(x, +)<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">// g++ -E -o main.i main.cpp<br>main.cpp:3:8: error: pasting &quot;x&quot; and &quot;+&quot; does not give a valid preprocessing token<br>   3 | CONCAT(x, +)<br>     |        ^<br>main.cpp:1:22: note: in definition of macro &#x27;CONCAT&#x27;<br>   1 | #define CONCAT(a, b) a ## b<br>     |                      ^<br></code></pre></td></tr></table></figure><p>可以看到，报错信息已经很显然了</p></blockquote><p>  需要注意的是，</p><ul><li><p>注释会转换为空白<br>在宏处理之前，预处理器会将注释转换为空白字符。这就意味着不能通过连接 <code>/</code> 和 <code>*</code> 来创建一个注释，注释在预处理阶段就会被移除；</p></li><li><p><code>##</code> 周围的空白<br>实际上可以在 <code>##</code> 操作符和其操作数之间放置任意数量的空白字符，包括空格、制表符和换行符等，这类空白字符在预处理时都会被忽略；</p></li><li><p><code>##</code> 操作数和注释<br>可以在将要被连接的参数中放置注释，因为注释会被转换为空白字符，所以最终会被 <code>##</code> 处理时忽略；</p></li><li><p><code>##</code> 操作数的位置错误<br><code>##</code> 操作数不能出现在宏体的开头或者结尾：也就是说，<code>##</code> 操作数的两侧必须有标记，当然传入宏参数时可以传入空白标记。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE(a, b) a ## b</span><br><br><span class="hljs-comment">// 正确使用，参数之间有注释</span><br><span class="hljs-built_in">PASTE</span>(a <span class="hljs-comment">/* comment */</span> , b)  <span class="hljs-comment">// 展开为 ab</span><br><br><span class="hljs-comment">// 错误使用，## 出现在宏的开始</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVALID_MACRO1 ##a  <span class="hljs-comment">// 错误，## 没有操作数</span></span><br><br><span class="hljs-comment">// 错误使用，## 出现在宏的结束</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVALID_MACRO2 a##  <span class="hljs-comment">// 错误，## 没有操作数</span></span><br></code></pre></td></tr></table></figure><h3 id="实际的例子">实际的例子</h3><p>  下面是一个运用宏连接使得代码更简洁的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">command</span>&#123;<br>    <span class="hljs-type">char</span>* name;<br>    <span class="hljs-built_in">void</span> (*function) (<span class="hljs-type">void</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">command</span> commands[] = &#123;<br>    &#123;<span class="hljs-string">&quot;quit&quot;</span>, quit_command&#125;,<br>    &#123;<span class="hljs-string">&quot;help&quot;</span>, help_command&#125;,<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>使用宏连接后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMAND(NAME) &#123;#NAME, NAME ## _command&#125;</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">command</span> commands[] = &#123;<br>    <span class="hljs-built_in">COMMAND</span>(quit),<br>    <span class="hljs-built_in">COMMAND</span>(help),<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>  这里分别使用宏<strong>字符串化</strong>和宏<strong>连接</strong>。</p><h2 id="可变参数宏-Variadic-Macros">可变参数宏[Variadic Macros]</h2><p>  和函数一样，宏也可以在声明时接受一个可变数量的参数，语法也与函数定义相似。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> eprintf(...) fprintf(stderr, __VA_ARGS__)</span><br></code></pre></td></tr></table></figure><p>  这样的宏被称为<strong>可变参数宏</strong>。当可变参数宏被调用时，<u>所有在最后一个命名参数之后传递给宏的参数（在这个例子中，宏没有命名参数）都被视为可变参数部分</u>。这意味着，<u>包括任何逗号在内的所有标记（tokens）都被视为可变参数</u>。</p><p>  在宏体内，<code>__VA_ARGS__</code>是一个特殊的标识符，用来表示传递给宏的所有可变参数。当宏展开时，<code>__VA_ARGS__</code>会被替换为宏调用中传递的所有实际参数。在宏展开过程中，<code>__VA_ARGS__</code>将被替换为宏调用中提供的实际参数序列。这意味着，宏调用中的参数将直接替换宏定义中的<code>__VA_ARGS__</code>，包括所有的逗号和标记。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(...) printf(__VA_ARGS__)</span><br><br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><br><span class="hljs-comment">// 预处理展开后：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>); <span class="hljs-comment">// 可以看到，逗号也作为可变参数的一部分</span><br></code></pre></td></tr></table></figure><ol><li>可变参数中的宏<br>  在可变参数被插入到宏展开中之前，它们会像普通参数一样被完全宏展开。也就是说，如果可变参数中包含宏，这些宏会在被传递到可变参数之前被展开。如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(...) printf(__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FMT <span class="hljs-string">&quot;Hello, %s!\n&quot;</span></span><br><br><span class="hljs-built_in">LOG</span>(FMT, <span class="hljs-string">&quot;world&quot;</span>);<br><br><span class="hljs-comment">// 预处理展开后：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>字符串化可变参数（#）<br>  同样可以使用 <code>#</code> 操作符来字符串化可变参数，这样可以将可变参数转化为字符串字面量。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGIFY(...) #__VA_ARGS__</span><br><br><span class="hljs-built_in">STRINGIFY</span>(some text)<br><br><span class="hljs-comment">// 预处理展开后：</span><br><span class="hljs-string">&quot;some text&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>使用 <code>##</code> 操作符<br>  实际上，使用 <code>##</code> 操作符将可变参数的首位标记与其他标记连接在一起也是允许的，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br><br><span class="hljs-built_in">PASTE_PREFIX</span>(MY_, function)<br><br><span class="hljs-comment">// 预处理展开后：</span><br>MY_function<br></code></pre></td></tr></table></figure><p>  需要注意的是，当使用 <code>##</code> 连接可变参数时，如果可变参数本身为空，那么对应连接的空白标记的情况，这个时候 <code>##</code> 操作符不会有任何效果。</p><p><br><br><br><br></p><p>  如果宏很复杂，那么可能希望变量参数有一个比<code>__VA_ARGS__</code>更具描述性的名称。<code>CPP</code>允许这样，作为一种扩展。可以立即在<code>...</code>前面写入一个参数名称；该名称用于变量参数。可以编写上面的<code>eprintf</code>宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> eprintf(args...) fprintf(stderr, args)</span><br></code></pre></td></tr></table></figure><p>需要注意的是，使用了拓展名之后，不能在同一个宏中同时使用拓展名和 <code>__VA_ARGS__</code>。</p><p>  就如前面的例子，在一个可变参数宏中既可以存在命名参数和可变参数，如上面的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br></code></pre></td></tr></table></figure><p>但这实际上存在一个可能的问题——当此时可变参数为空时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br><br><span class="hljs-built_in">PASTE_PREFIXZ</span>(MY_, )<br></code></pre></td></tr></table></figure><p>在 <code>C++20</code> 以前，<code>PASTE_PREFIXZ(MY_, )</code> 中的 <code>,</code> 被视为可变参数的一部分，所以最终展开的结果是 <code>MY_,</code>，这与我们的预期不符。这个问题在 <code>C++20</code> 后已经被解决了——实际上我们已经可以完全忽略可变参数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br><br><span class="hljs-built_in">PASTE_PREFIXZ</span>(MY_) <span class="hljs-comment">// 这里逗号都可以不要</span><br></code></pre></td></tr></table></figure><p>  其次，<code>C++20</code>引入了<code>__VA_OPT__</code>函数宏。此宏可能<u>只出现在可变参数宏的定义中</u>。它提供了一种条件展开机制，允许开发者根据可变参数是否存在来决定是否展开某些代码。其工作原理：</p><ol><li><p>条件展开</p><ul><li><code>__VA_OPT__</code>宏函数检查可变参数（<code>variable argument</code>）是否有任何标记（<code>tokens</code>）；</li><li>如果可变参数中包含至少一个标记，那么<code>__VA_OPT__</code>会将其参数展开为这些标记；</li><li>如果可变参数中不包含任何标记（即为空），那么<code>__VA_OPT__</code>展开为空，不会产生任何代码。</li></ul></li><li><p>语法</p><ul><li><code>__VA_OPT__</code>的使用语法是<code>__VA_OPT__(参数)</code>，其中参数是当可变参数非空时应该展开的代码；</li><li>常用：<code>__VA_OPT__(op1, op2)</code>：其中 <code>op1</code> 对应可变参数中不包含任何标记时的操作，<code>op2</code> 对应可变参数中包含标记时的操作。<code>op1</code> 通常为空，使得当可变参数中不包含任何标记时展开为空。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(msg, ...) printf(<span class="hljs-string">&quot;Log: &quot;</span> msg <span class="hljs-string">&quot;\n&quot;</span> __VA_OPT__(, ##__VA_ARGS__) )</span><br><br><span class="hljs-comment">// 调用示例</span><br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;This is a message&quot;</span>);<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;This is a message&quot;</span>, <span class="hljs-string">&quot; with additional info&quot;</span>);<br><br><span class="hljs-comment">// 预处理之后：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Log: This is a message\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Log: This is a message, with additional info\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>LOG</code>宏定义了一个可变参数宏，其中使用了<code>__VA_OPT__</code>；</li><li>当只有<code>msg</code>参数被提供时，<code>__VA_ARGS__</code>为空，<code>__VA_OPT__(, ##__VA_ARGS__)</code>展开为空，因此没有额外的代码被添加；</li><li>当提供了额外的参数时，<code>__VA_ARGS__</code>非空，<code>__VA_OPT__(, ##__VA_ARGS__)</code>展开为, <code>##__VA_ARGS__</code>，这允许<code>printf</code>函数接受额外的参数。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>C</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（二）</title>
    <link href="/2024/11/20/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_2/"/>
    <url>/2024/11/20/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、宏参数">一、宏参数</h2><p>  和真正的函数一样，类函数宏也<strong>可以接受参数</strong>。类函数宏需要参数时，你需要将参数插入圆括号<code>()</code>中，这和调用函数时一样(函数声明和定义时需要指明参数类型，宏是文本替换，所以不需要提供参数类型信息)。需要注意的是，宏参数须为有效的 <code>C/C++</code> 标识符，并且在<strong>存在多个参数时使用逗号隔开，以及可选的空格</strong>。</p><h3 id="1-1-调用宏的方式">1.1 调用宏的方式</h3><p>  当想要使用一个带有参数的宏时，宏名称后接一对圆括号<code>()</code>，并且<strong>在括号内插入实际的参数列表，参数列表用逗号隔开</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) ((a) &gt; (b)? (a): (b))</span><br><br><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="1-2-宏调用可以跨多行">1.2 宏调用可以跨多行</h3><p>  宏的调用不必限制在源文件的单行内，它<strong>可以跨越多行</strong>。这意味着你可以在调用宏时，在参数列表中使用换行符，以提高代码的可读性。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<br>    a + b,<br>    c + d<br>);<br></code></pre></td></tr></table></figure><p>因为上一节讲过，所有宏都会被展开成源代码中的一行。</p><h3 id="1-3-参数数量必须匹配">1.3 参数数量必须匹配</h3><p>  当然，在调用宏时<strong>提供的参数数量必须与宏定义中的参数数量相匹配</strong>。如果宏定义了两个参数，调用时也必须提供两个参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><h3 id="1-4-宏展开时参数的替换">1.4 宏展开时参数的替换</h3><p>  当宏被展开时，<strong>宏体</strong>中的每个参数都会被对应的实际参数替换。这里的<strong>替换</strong>指的是<u>将宏定义中的参数名称替换为实际参数的代码</u>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) ((a) &gt; (b)? (a): (b))</span><br><br><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = ((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><h3 id="1-5-参数的使用是可选的">1.5 参数的使用是可选的</h3><p>  <strong>宏中定义的参数的使用是可选的</strong>，宏体定义的参数不一定要在宏体中使用。可以定义一个参数，但在宏体中不使用它，或者只使用部分参数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_LOG(x, y) printf(<span class="hljs-string">&quot;Value of x: %d\n&quot;</span>, x)</span><br></code></pre></td></tr></table></figure><h3 id="1-6-宏调用时参数的处理规则">1.6 宏调用时参数的处理规则</h3><h4 id="1-参数前后的空白字符被丢弃">1. 参数前后的空白字符被丢弃</h4><p>  在宏调用中，每个参数前后的空白字符（空格、制表符等）都会被丢弃。这意味着，无论实际参数前后有多少空白字符，它们都不会出现在宏展开后的代码中。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(    <span class="hljs-number">2</span>    ,    <span class="hljs-number">3</span>    );<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = ((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>可以看到，参数 <code>2</code> 和<code>3</code>前后的空白字符都被丢弃。</p><h4 id="2-参数内部的空白字符被压缩为单个空格">2. 参数内部的空白字符被压缩为单个空格</h4><p>  在参数内部，所有的空白字符（包括空格、制表符等）都会被压缩为单个空格。这意味着，无论参数内部有多少连续的空白字符，它们都会被替换为一个空格。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span> +    <span class="hljs-number">4</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = ((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span> + <span class="hljs-number">4</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span> + <span class="hljs-number">4</span>));<br></code></pre></td></tr></table></figure><p>参数<code>3 +    4</code>中的多个空白字符被压缩成了一个空格。</p><h4 id="3-参数内的括号必须平衡">3. 参数内的括号必须平衡</h4><p>  在参数内部，如果使用了圆括号，那么这些圆括号必须平衡（即每对开括号(必须有对应的闭括号)）。<u>在平衡的圆括号内部的逗号不会导致参数的结束，简单理解就是圆括号中的逗号不会将其分隔成不同参数</u>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = (((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) &gt; (<span class="hljs-number">3</span>)? ((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>且不论上述宏展开后的代码是否合法（实际上宏展开也不会进行语法检查），参数<code>(2, 3)</code>并没有被分隔成两个参数 <code>(2</code> 和 <code>3)</code>。所以说，圆括号务必要平衡。</p><h4 id="4-方括号和花括号不需要平衡">4. 方括号和花括号不需要平衡</h4><p>  对于方括号<code>[]</code>和花括号<code>&#123;&#125;</code>，不需要平衡，其内部的逗号仍然会被视为参数分隔符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">3</span>); <span class="hljs-comment">// 三个参数 [2、3] 和 3</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-number">3</span>); <span class="hljs-comment">// 三个参数 &#123;2、3&#125; 和 3</span><br></code></pre></td></tr></table></figure><p>这里<strong>实际上是无法进行宏展开的</strong>，会导致编译错误，因为宏定义时只接受两个参数，而这里提供了三个参数。</p><h3 id="1-7-宏参数的展开规则">1.7 宏参数的展开规则</h3><ol><li><p>宏参数的完全展开<br>  <u>在宏体中替换参数之前，所有传递给宏的实际参数都会先进行完全的宏展开</u>。这意味着，如果实际参数本身是一个宏，或者包含宏，那么这些宏会首先被展开。</p></li><li><p>替换后的再次扫描<br>  替换参数到宏体之后，整个宏体（包括替换后的参数）会再次被扫描，以查找是否有更多的宏需要展开。这个过程会持续进行，直到没有更多的宏可以展开。</p></li></ol><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>第一次，参数进行展开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>), <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>第二次，替换后的再次扫描：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = ((((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>))) &gt; (<span class="hljs-number">3</span>)? (((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>))): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>事实上，你甚至在为宏传递空参数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = (() &gt; (<span class="hljs-number">3</span>)? (): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>但是在传空参数时仍然要确保参数的匹配。</p><p>  需要注意的是：出现在<strong>字符串中的宏参数不会被它们相应的实际参数替换</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo(x) x, <span class="hljs-string">&quot;x&quot;</span></span><br><br><span class="hljs-comment">// 实际调用</span><br><span class="hljs-built_in">foo</span>(bar)<br><br><span class="hljs-comment">// 预处理展开后</span><br>bar, <span class="hljs-string">&quot;x&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>到这里，你一定会疑惑，为什么我们在宏定义时，宏体中的参数都会包裹在一对圆括号内</p></blockquote><h3 id="1-8-宏体参数用圆括号包裹的原因">1.8 宏体参数用圆括号包裹的原因</h3><h4 id="1-操作符优先级：">1. 操作符优先级：</h4><p>  在C/C++中，宏参数可能会与宏体中的其他代码一起参与运算。如果不使用括号，可能会因为操作符优先级的问题导致宏的展开结果与预期不符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) x * x</span><br></code></pre></td></tr></table></figure><p>  如果你使用<code>SQUARE(a + b)</code>，宏会展开为<code>a + b * a + b</code>，这显然不是我们想要的结果，因为按照乘法优先于加法的规则，它实际上变成了<code>a + (b * a) + b</code>。正确的结果应该是<code>(a + b) * (a + b)</code>。</p><h4 id="2-使用括号可以确保参数作为一个整体被处理：">2. 使用括号可以确保参数作为一个整体被处理：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) (x) * (x)</span><br></code></pre></td></tr></table></figure><p>  这样，<code>SQUARE(a + b)</code>会正确展开为<code>(a + b) * (a + b)</code>。</p><h4 id="3-避免宏参数为空：">3. 避免宏参数为空：</h4><p>  如果宏的参数可能为空（例如，在宏定义中使用<code>##</code>运算符进行连接时），不使用括号可能会导致编译错误。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EMPTY()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GLUE(x, y) x ## y</span><br><br><span class="hljs-built_in">GLUE</span>(EMPTY, <span class="hljs-type">int</span>) var; <span class="hljs-comment">// 这将尝试定义一个名为&quot;int&quot;的变量，而不是&quot;Emptyint&quot;</span><br></code></pre></td></tr></table></figure><p>  如果<code>EMPTY</code>宏没有括号，<code>GLUE(EMPTY, int)</code>将尝试将<code>EMPTY</code>和<code>int</code>连接起来，而不是将<code>EMPTY()</code>作为一个整体与<code>int</code>连接。</p><h4 id="4-参数可能包含多个标记：">4. 参数可能包含多个标记：</h4><p>  如果宏参数本身是一个复合表达式或多个标记，那么使用括号可以确保整个表达式被正确处理。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE_AND_INCREMENT(x) ((x) * (x)) + 1</span><br></code></pre></td></tr></table></figure><p>  这里，<code>(x)</code>确保了<code>x</code>的整个表达式被乘以自身，然后再加<code>1</code>。</p><h4 id="5-提高代码的可读性和一致性：">5. 提高代码的可读性和一致性：</h4><p>  使用括号可以使宏的定义更加清晰，让阅读代码的人更容易理解宏的意图和行为。</p><h2 id="二、字符串化">二、字符串化</h2><p>  预处理器中的字符串化（<code>Stringizing</code>）操作。这是一种将宏参数转换为字符串常量的技术。有时可能希望将宏参数转换为字符串常量。<u>在字符串常量中，参数不会被替换，但是可以使用<code>#</code>预处理操作符来实现这一点</u>。</p><h3 id="2-1-操作符的使用">2.1 #操作符的使用</h3><p>  当宏参数前面有一个<code>#</code>操作符时，预处理器会用实际参数的文本内容替换它，并将其转换为字符串常量。这与普通的参数替换不同，因为参数不会首先被宏展开。</p><p>  字符串化操作<u>不会在参数替换之前对参数进行宏展开</u>。这意味着如果参数是一个宏，它不会被展开，而是直接将其名称作为字符串插入。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING hello</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGFY(Argu) #Argu</span><br><br><span class="hljs-built_in">STRINGFY</span>(STRING)<br></code></pre></td></tr></table></figure><p>预处理展开之后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;STRING&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到，宏<code>STRINGFY</code>的参数也是一个宏<code>STRING</code>，但并没有被展开为 <code>hello</code>，而是直接将其名称字符串化为了字符串常量<code>&quot;STRING&quot;</code>。</p><p>  不能直接将参数与周围的文本组合在一起并一次性字符串化。相反，你可以编写一系列相邻的字符串常量和字符串化的参数。预处理器会将字符串化的参数替换为字符串常量，然后，编译器会将所有相邻的字符串常量合并为一个长字符串。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> WARN_IF(EXP) \</span><br><span class="hljs-meta">do &#123; <span class="hljs-keyword">if</span> (EXP) \</span><br><span class="hljs-meta">        fprintf (stderr, <span class="hljs-string">&quot;Warning: &quot;</span> #EXP <span class="hljs-string">&quot;\n&quot;</span>); &#125; \</span><br><span class="hljs-meta">while (0)</span><br><span class="hljs-built_in">WARN_IF</span> (x == <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>预处理器展开后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span> &#123; <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) \<br>    <span class="hljs-built_in">fprintf</span> (stderr, <span class="hljs-string">&quot;Warning: &quot;</span> <span class="hljs-string">&quot;x == 0&quot;</span> <span class="hljs-string">&quot;\n&quot;</span>); \<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>注意，这里的<code>\</code>表示行间是连接的，因为宏展开会成一行，这里为了方便，增加了换行。可以看到，<code>EXP</code> 的参数被替换为 <code>if</code> 语句中的条件参数和 <code>fprintf</code> 参数中的 <code>string</code> 参数。<u>如果 <code>x</code> 是一个宏，它将在 <code>If</code> 语句中展开，但不会在字符串中展开</u>。后面的几个字符串常量<code>&quot;Warning: &quot; &quot;x == 0&quot; &quot;\n&quot;</code>会在编译器的帮助下合并成一个字符串常量。</p><blockquote><p>这里其实还提到了 <code>do...while(0)</code> 循环的使用，这是一种技巧，将在后续章节探讨。</p></blockquote><p>  可见，字符串化不仅仅是在宏参数周围添加双引号那么简单。预处理器会进行额外的处理，以确保生成的字符串常量是有效的，并且包含正确的内容。</p><h3 id="2-2-宏参数字符串化的细节处理">2.2 宏参数字符串化的细节处理</h3><h4 id="1-预处理器对引号和反斜杠的处理">1. 预处理器对引号和反斜杠的处理</h4><p>  当宏参数中包含字符串常量时，预处理器会对其进行转义处理。这意味着，如果宏参数中包含双引号或反斜杠，预处理器会在它们前面添加反斜杠来进行转义。这样做的目的是为了确保生成的字符串常量在<code>C/C++</code>语言中是有效的。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGFY(Argu) #Argu</span><br><br><span class="hljs-built_in">STRINGFY</span>(<span class="hljs-string">&quot;hello\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>预处理器展开后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;\&quot;hello\\n\&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-非字符串或字符常量中的反斜杠不加倍">2. 非字符串或字符常量中的反斜杠不加倍</h4><p>  如果反斜杠不在字符串或字符常量中，它们不会被加倍。例如，<code>\n</code>单独字符串化时，结果就是<code>&quot;\n&quot;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGFY(Argu) #Argu</span><br><br><span class="hljs-built_in">STRINGFY</span>(\n)<br></code></pre></td></tr></table></figure><p>预处理器展开后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;\n&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3-字符串化中的空白处理">3. 字符串化中的空白处理</h4><p>  在字符串化过程中，宏参数中的所有前导和尾随空白都会被忽略。文本中的任何空白序列（空格、制表符等）在字符串化结果中会被转换为单个空格。其实也是一种特殊的宏参数处理。</p><h4 id="4-无法将宏参数转换为字符常量">4. 无法将宏参数转换为字符常量</h4><p>  没有办法将宏参数直接转换为字符常量。这是因为字符常量在<code>C/C++</code>语言中是用单引号括起来的单个字符，而字符串化操作是将整个宏参数转换为双引号括起来的字符串常量。</p><h3 id="2-3-如何字符串化宏参数的展开">2.3 如何字符串化宏参数的展开</h3><p>  如果要将<strong>宏参数展开后的结果转换成字符串常量</strong>，则需要使用<strong>两级宏</strong>（即<strong>嵌套宏</strong>）来实现。这是因为在预处理阶段，<u>宏参数首先被展开，然后才进行字符串化</u>。如果直接在宏中使用<code>#</code>操作符来字符串化宏参数，那么字符串化的是宏参数本身，而不是它展开后的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xstr(s) str(s)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> str(s) #s</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo 4</span><br><br><span class="hljs-built_in">xstr</span> (foo)<br></code></pre></td></tr></table></figure><p>第一次展开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">xstr</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// 第一次展开并非字符串化，故参数会展开</span><br></code></pre></td></tr></table></figure><p>第二次展开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">str</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// 第二次展开是 xstr 展开</span><br></code></pre></td></tr></table></figure><p>然后字符串化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;4&quot;</span> <span class="hljs-comment">// 最后是字符串化</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>C</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（一）</title>
    <link href="/2024/11/18/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_1/"/>
    <url>/2024/11/18/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_1/</url>
    
    <content type="html"><![CDATA[<h3 id="宏是什么？">宏是什么？</h3><p>  <strong>宏</strong>(<code>Macros</code>)是一段代码片段，每个<strong>宏</strong>被赋予了一个名称。<strong>无论何时使用该名称，都将由宏的内容替换</strong>（其实就是文本替换）。宏有两种——<strong>类对象宏(<code>Object-like Macros</code>)<strong>和</strong>类函数宏(<code>Function-like Macros</code>)</strong>。它们的差异主要体现在使用时，使用<strong>类对象宏</strong>时类似于数据对象，使用<strong>类函数宏</strong>时类似于函数调用。</p><p>$$<br>宏<br>\begin{cases}<br>类对象宏 \\<br>类函数宏<br>\end{cases}$$</p><h3 id="类对象宏-Object-like-Macros">类对象宏(Object-like Macros)</h3><p>  <strong>类对象宏</strong>其实就是一个简单的<strong>标识符</strong>，其在代码中被使用之处会被其所指的代码片段给替换。之所以将其称为<strong>类对象宏</strong>，是因为在代码中使用<strong>类对象宏</strong>时就像在使用普通的数据对象一样。通常的<u>使用场景是给数值常量赋予符号名称</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 示例1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14</span><br></code></pre></td></tr></table></figure><p>  <u>在<code>C/C++</code>中，宏是通过预处理指令<code>#define</code>来创建的</u>。这个指令告诉预处理器定义一个新的宏（预处理器是C/C++编译过程中的一个阶段，负责处理源代码中的预处理指令，如宏定义、文件包含和条件编译等）。</p><p>  <code>#define</code>后面紧跟的是宏的<strong>名称</strong>。宏的名称<strong>通常以大写字母表示</strong>，以区分于变量和其他标识符，这是一种约定俗成的命名习惯，有助于提高代码的可读性。</p><p>  宏名称之后是宏的<strong>替换列表(replacement list)</strong>，也就是<u>当宏被使用时，预处理器将宏名称替换为这个列表中的代码</u>。这个替换列表有时被称为宏的“<strong>体</strong>”(<code>body</code>)、“<strong>展开</strong>”(<code>expansion</code>)。</p><blockquote><p>需要注意得是，宏定义后没有分号！本质上宏是一种预编译指令，并不是<code>C/C++</code>得一条语句，所以没有分号。</p></blockquote><p>  示例1中定义了一个名为 <code>PI</code> 的宏表示圆周率，其对应的<strong>宏体</strong>为我们希望圆周率所取得的数值 <code>3.14</code>。如果在 <code>define</code> 语句之后，某个代码位置使用了这个宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> perimeter = <span class="hljs-number">2</span>*PI;<br></code></pre></td></tr></table></figure><p>然后 <code>C/C++</code> 预处理器将识别并展开宏 <code>PI</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> perimeter = <span class="hljs-number">2</span>*<span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><p>  通常，<u>宏的主体结束于 <code>#define</code> 行的末尾</u>。如果需要，可以使用<strong>反斜杠</strong><code>\</code><strong>换行</strong>将定义继续到多行。然而，<u>当宏被展开时，它们都会出现在一行中</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUMBERS 1, \</span><br><span class="hljs-meta">                2, \</span><br><span class="hljs-meta">                3</span><br><br><span class="hljs-type">int</span> nums[] = &#123;NUMBERS&#125;;<br><br><span class="hljs-comment">// 预处理展开后：</span><br><br><span class="hljs-type">int</span> nums[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>这里官方文档说：因为预处理后宏会变成一行，那么报错信息提供的行号和我们实际所看到的行号就存在偏差。可能因为时间原因，这个问题已经不存在了：</p><p><img src="/img/in_posts/Macros/code1.png" alt="错误代码"><br>这段代码里，<code>return</code> 语句后没写分号。查看报错信息：<br><img src="/img/in_posts/Macros/code1_err_info.png" alt="报错信息"><br>可以看到，报错信息里面行号是正常显示的，这个问题可以忽略。</p></blockquote><p>  在<code>C/C++</code>语言中定义宏时，宏体可以包含任何内容，只要这些内容能够分解成有效的<strong>预处理标记</strong>（<code>preprocessing tokens</code>）。这里的“预处理标记”指的是<u>预处理器能够识别的基本单位，比如关键字、标识符、字面量、运算符等</u>。</p><blockquote><p>什么意思？如下：<br><strong>无限制的内容</strong><br>宏体中可以放入任何字符序列，<u>预处理器不会对宏体的内容做语法检查，它只负责将宏名替换为宏体的内容</u>；<br>正因如此，宏体中的代码片段甚至不必看起来是 <code>C/C++</code> 的代码，但是编译结束可能会投来编译错误.😂</p></blockquote><p>  <code>C/C++</code> 预处理器<strong>按顺序扫描程序</strong>。宏定义在编写它们的地方生效，<u>也即是说在其定义之处之后的作用域内有效</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = N;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 3</span><br><span class="hljs-type">int</span> b = N;<br></code></pre></td></tr></table></figure><p>预处理之后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = N;<br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>这里就出错了，预处理器按顺序扫描到第一个语句时，<code>N</code> 并没有被定义，而在其后方才被定义为宏，于是只有<code>b</code>的赋值语句中 <code>N</code> 被正确展开成了 <code>3</code>。</p><p>  <code>C/C++</code>预处理器在处理宏时的展开过程。<u>当宏体中出现宏的调用（即宏名的使用）时，预处理器会将展开后的宏体中的宏继续展开</u>。这个过程是<strong>递归</strong>的，直到所有的宏都被替换为它们的值或者代码片段。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABLESIZE BUFFERSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 1024</span><br></code></pre></td></tr></table></figure><p>那么实际上，<code>TABLESIZE</code> 首先被展开成 <code>BUFSIZE</code>，然后 <code>BUFSIZE</code> 又被展开为 <code>4</code>，所以最终的效果是使用 <code>TABLESIZE</code> 的地方都被展开成了 <code>4</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">TABLESIZE <br>    -&gt; BUFSIZE<br>    -&gt; <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>  注意，在定义 <code>TABLESIZE</code> 时没有定义 <code>BUFSIZE</code>。<code>TABLESIZE</code> 的<code>#define</code>完全使用指定的展开式，因为不会进行语法检查，并且不检查它是否也包含宏名称。只有当您使用 <code>TABLESIZE</code> 时，才会扫描其展开的结果以查找更多的宏名称，因为使用 <code>TABLESIZE</code> 之处也处于 <code>BUFSIZE</code> 作用域之内。这也说明了，宏指令的位置与最终展开的结果相关，预处理最终将会使用当前生效的宏进行展开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABLESIZE BUFSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> BUFSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 37</span><br></code></pre></td></tr></table></figure><p>这个示例中，<code>TABLESIZE</code> 最终被展开为了 <code>37</code>。</p><p>  还有一种情况：如果宏体中包含自身的宏名称(直接或通过中间宏) ，<u>则在检查更多宏时不再展开。这可以防止无限递归</u>。下面是一个例子来说明这种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO FOO</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>FOO</code> 宏被定义为它自己。当预处理器遇到 <code>FOO</code> 时，它会尝试展开 <code>FOO</code>，但发现 <code>FOO</code> 的定义就是它自己，所以预处理器不会再次展开 <code>FOO</code>，避免了无限递归。</p><p>另一个更复杂的例子，涉及中间宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BAR FOO</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO BAR</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>FOO</code> 被定义为 <code>BAR</code>，而 <code>BAR</code> 被定义为 <code>FOO</code>。如果预处理器尝试展开 <code>FOO</code>，它会被替换为 <code>BAR</code>，然后 <code>BAR</code> 又会尝试展开为 <code>FOO</code>，但此时预处理器已经知道 <code>FOO</code> 会展开为 <code>BAR</code>，所以它不会再次展开 <code>FOO</code>，避免了无限递归。</p><p>在这两种情况下，预处理器都会停止进一步展开宏，以防止无限递归的发生。这种自我引用的宏定义通常不是有意为之的，因为它们不会产生有用的结果，但它们确实展示了预处理器如何处理宏的递归展开，这部分将在后续 <code>自引用宏章节</code> 介绍。</p><h3 id="类函数宏-Function-like-Macros">类函数宏(Function-like Macros)</h3><p>  实际上，还可以定义<strong>看起来像函数调用的宏</strong>。这些被称为<strong>类函数宏</strong>。要定义一个类似函数的宏，同样使用 <code>#define</code>指令，但在<u>宏名称后紧接一对括号</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lang_init()  c_init()</span><br><br><span class="hljs-comment">// 预处理后</span><br><span class="hljs-built_in">lang_init</span>()<br>     -&gt; <span class="hljs-built_in">c_init</span>()<br></code></pre></td></tr></table></figure><p>当定义了一个类函数宏时，只有当这个宏的名字后面紧跟着一对括号时，它才会被展开。<u>如果宏的名字后面没有括号，那么它就不会被展开，而是保持原样</u>。这在存在同名的<strong>函数</strong>和<strong>类函数宏</strong>时，希望调用真实函数而不是宏时进行区分很有用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo() <span class="hljs-comment">/* optimized inline version */</span></span><br>...<br><span class="hljs-built_in">foo</span>();<br>funcptr = foo;<br></code></pre></td></tr></table></figure><p>这里对 <code>foo()</code> 的调用将使用<strong>宏</strong>，而函数指针 <code>funcptr</code> 获取的是<strong>函数</strong><code>foo</code> 的地址。但是这里如果将 <code>foo()</code> 进行展开将会出现语法错误……</p><p>  如果在宏定义中的宏名称和括号之间放置空格，则不是类函数宏，而是定义了一个类对象宏，其扩展恰好以一对括号开始：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lang_init ()  c_init()</span><br><br><span class="hljs-comment">// 预处理后</span><br><span class="hljs-built_in">lang_init</span>()<br>     -&gt; ()  <span class="hljs-built_in">c_init</span>()()<br></code></pre></td></tr></table></figure><p>需要注意。</p><!-- [官方文档](https://gcc.gnu.org/onlinedocs/cpp/Macros.html) -->]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>C</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试博客功能</title>
    <link href="/2024/11/16/test/"/>
    <url>/2024/11/16/test/</url>
    
    <content type="html"><![CDATA[<h1>线性代数——二次型</h1><h2 id="一、二次型的定义及其矩阵表达式">一、二次型的定义及其矩阵表达式</h2><p>  $n$ 元变量 $x_1$，$x_2$，…，$x_n$ 的二次齐次多项式</p><p>$$f(x_1, x_2, …, x_n) = a_{11}x_1^2+2a_{12}x_1x_2+…+2a_{1n}x_1x_n\\+a_{22}x_2^2+2a_{23}x_2x_3+…+2a_{2n}x_2x_n\\+…+a_{nm}x_n^2$$</p><p>称为 $n$ <strong>元二次型</strong>，简称<strong>二次型</strong>.</p><p>  这里只介绍系数 $a_{ij} \in R(i \le j; i,j = 1, 2, …, n)$的情况，称此二次型 $f$ 为<strong>实二次型</strong>.</p><p>  因为 $x_ix_j = x_jx_i$，于是令 $a_{ij} = a_{ji}(i,j = 1, 2, …, n)$，则 $2a_{ij}x_ix_j = a_{ij}x_ix_j+a_{ji}x_jx_i$，于是令</p><p>$$<br>A = \begin{pmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}<br>\end{pmatrix}$$</p><p>$$x = \begin{pmatrix}<br>x_{1} \\<br>x_{2} \\<br>\vdots \\<br>x_{n} \\<br>\end{pmatrix}$$</p><p>则二次型可以表示为</p><p>$$f(x) = x^TAx$$</p><p>其中，<strong>实对称矩阵</strong>$A$称为<strong>二次型</strong>$f(x)$<strong>的矩阵</strong>. 这里 $A$ 是一个对称矩阵，$A_{ij} = (a_{ij}), a_{ij} = a_{ji}$，即满足 $A^T = A$. 实际上二次型可以有多种写法，如：<br>$$f(x) = x_1^2+x_2^2+4x_1x_2$$<br>或<br>$$f(x) = x_1^2+x_2^2+1x_1x_2+3x_2x_1$$</p><p>于是对应的矩阵 $A$ 分别为：<br>$$<br>A = \begin{pmatrix}<br>1 &amp; 2  \\<br>2 &amp; 1 \\<br>\end{pmatrix}$$</p><p>和</p><p>$$<br>A = \begin{pmatrix}<br>1 &amp; 1  \\<br>3 &amp; 1 \\<br>\end{pmatrix}$$</p><p>而这里作了规定，<strong>二次型的矩阵必须为对称矩阵</strong>，那么如此代表二次型的矩阵就是<strong>唯一</strong>的了.</p><h2 id="二、合同变换，二次型的合同标准型、规范型">二、合同变换，二次型的合同标准型、规范型</h2><h3 id="1-线性变换的定义">1.线性变换的定义</h3><p>  对于 $n$元二次型 $f(x_1, x_2, …, x_n)$，若令</p><p>$$ \left{<br>\begin{aligned}<br>x_1 &amp;= c_{11}y_1 + c_{12}y_2 + \cdots + c_{1n}y_n \<br>x_2 &amp;= c_{21}y_1 + c_{22}y_2 + \cdots + c_{2n}y_n \<br>&amp;\vdots \<br>x_n &amp;= c_{n1}y_1 + c_{n2}y_2 + \cdots + c_{nn}y_n<br>\end{aligned}<br>\right.<br>$$</p><p>记<br>$$x = \begin{pmatrix}<br>x_{1} \\<br>x_{2} \\<br>\vdots \\<br>x_{n} \\<br>\end{pmatrix}$$</p><p>$$<br>C = \begin{pmatrix}<br>c_{11} &amp; c_{12} &amp; \cdots &amp; c_{1n} \\<br>c_{21} &amp; c_{22} &amp; \cdots &amp; c_{2n} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>c_{n1} &amp; c_{n2} &amp; \cdots &amp; c_{nn}<br>\end{pmatrix}$$</p><p>$$y = \begin{pmatrix}<br>y_{1} \\<br>y_{2} \\<br>\vdots \\<br>y_{n} \\<br>\end{pmatrix}$$</p><p>则，上式可以写为：</p><p>$$x = Cy$$<br>上述变换称为<strong>线性变换</strong>，若线性变换的系数矩阵$C$可逆，即 $|C| \ne 0$，则称为<strong>可逆线性变换</strong>. 现给出：<br>$$f(x) = x^TAx$$<br>令 $x = Cy$，则<br>$$f(x) = (Cy)^TA(Cy) = y^T(C^TAC)y$$<br>记 $B = C^TAC$，则<br>$$f(x) = y^TBy = g(y)$$<br>显然，这又是一个新的二次型：即二次型 $f(x)=x^TAx$通过线性变换 $x=Cy$ 得到了一个新的二次型 $g(y) = y^TBy$</p><p><img src="/img/in_posts/blog_start/changli.jpg" alt=""></p><p>测试一下是否能够实现文章内跳转：<br><a href="Concurrency/c++%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B1%82%E6%AC%A1%E9%94%81.md">C++多线程-层次锁</a></p>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
      <tag>latex</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
