<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（一）</title>
    <link href="/2024/11/18/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_1/"/>
    <url>/2024/11/18/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_1/</url>
    
    <content type="html"><![CDATA[<h3 id="宏是什么？">宏是什么？</h3><p>  <strong>宏</strong>(<code>Macros</code>)是一段代码片段，每个<strong>宏</strong>被赋予了一个名称。<strong>无论何时使用该名称，都将由宏的内容替换</strong>（其实就是文本替换）。宏有两种——<strong>类对象宏(<code>Object-like Macros</code>)<strong>和</strong>类函数宏(<code>Function-like Macros</code>)</strong>。它们的差异主要体现在使用时，使用<strong>类对象宏</strong>时类似于数据对象，使用<strong>类函数宏</strong>时类似于函数调用。</p><p>$$<br>宏<br>\begin{cases}<br>类对象宏 \<br>类函数宏<br>\end{cases}$$</p><h3 id="类对象宏-Object-like-Macros">类对象宏(Object-like Macros)</h3><p>  <strong>类对象宏</strong>其实就是一个简单的<strong>标识符</strong>，其在代码中被使用之处会被其所指的代码片段给替换。之所以将其称为<strong>类对象宏</strong>，是因为在代码中使用<strong>类对象宏</strong>时就像在使用普通的数据对象一样。通常的<u>使用场景是给数值常量赋予符号名称</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 示例1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14</span><br></code></pre></td></tr></table></figure><p>  <u>在<code>C/C++</code>中，宏是通过预处理指令<code>#define</code>来创建的</u>。这个指令告诉预处理器定义一个新的宏（预处理器是C/C++编译过程中的一个阶段，负责处理源代码中的预处理指令，如宏定义、文件包含和条件编译等）。</p><p>  <code>#define</code>后面紧跟的是宏的<strong>名称</strong>。宏的名称<strong>通常以大写字母表示</strong>，以区分于变量和其他标识符，这是一种约定俗成的命名习惯，有助于提高代码的可读性。</p><p>  宏名称之后是宏的<strong>替换列表(replacement list)</strong>，也就是<u>当宏被使用时，预处理器将宏名称替换为这个列表中的代码</u>。这个替换列表有时被称为宏的“<strong>体</strong>”(<code>body</code>)、“<strong>展开</strong>”(<code>expansion</code>)。</p><blockquote><p>需要注意得是，宏定义后没有分号！本质上宏是一种预编译指令，并不是<code>C/C++</code>得一条语句，所以没有分号。</p></blockquote><p>  示例1中定义了一个名为 <code>PI</code> 的宏表示圆周率，其对应的<strong>宏体</strong>为我们希望圆周率所取得的数值 <code>3.14</code>。如果在 <code>define</code> 语句之后，某个代码位置使用了这个宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> perimeter = <span class="hljs-number">2</span>*PI;<br></code></pre></td></tr></table></figure><p>然后 <code>C/C++</code> 预处理器将识别并展开宏 <code>PI</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> perimeter = <span class="hljs-number">2</span>*<span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><p>  通常，<u>宏的主体结束于 <code>#define</code> 行的末尾</u>。如果需要，可以使用<strong>反斜杠</strong><code>\</code><strong>换行</strong>将定义继续到多行。然而，<u>当宏被展开时，它们都会出现在一行中</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUMBERS 1, \</span><br><span class="hljs-meta">                2, \</span><br><span class="hljs-meta">                3</span><br><br><span class="hljs-type">int</span> nums[] = &#123;NUMBERS&#125;;<br><br><span class="hljs-comment">// 预处理展开后：</span><br><br><span class="hljs-type">int</span> nums[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>这里官方文档说：因为预处理后宏会变成一行，那么报错信息提供的行号和我们实际所看到的行号就存在偏差。可能因为时间原因，这个问题已经不存在了：</p><p><img src="/img/in_posts/Macros/code1.png" alt="错误代码"><br>这段代码里，<code>return</code> 语句后没写分号。查看报错信息：<br><img src="/img/in_posts/Macros/code1_err_info.png" alt="报错信息"><br>可以看到，报错信息里面行号是正常显示的，这个问题可以忽略。</p></blockquote><p>  在<code>C/C++</code>语言中定义宏时，宏体可以包含任何内容，只要这些内容能够分解成有效的<strong>预处理标记</strong>（<code>preprocessing tokens</code>）。这里的“预处理标记”指的是<u>预处理器能够识别的基本单位，比如关键字、标识符、字面量、运算符等</u>。</p><blockquote><p>什么意思？如下：<br><strong>无限制的内容</strong><br>宏体中可以放入任何字符序列，<u>预处理器不会对宏体的内容做语法检查，它只负责将宏名替换为宏体的内容</u>；<br>正因如此，宏体中的代码片段甚至不必看起来是 <code>C/C++</code> 的代码，但是编译结束可能会投来编译错误.😂</p></blockquote><p>  <code>C/C++</code> 预处理器<strong>按顺序扫描程序</strong>。宏定义在编写它们的地方生效，<u>也即是说在其定义之处之后的作用域内有效</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = N;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 3</span><br><span class="hljs-type">int</span> b = N;<br></code></pre></td></tr></table></figure><p>预处理之后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = N;<br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>这里就出错了，预处理器按顺序扫描到第一个语句时，<code>N</code> 并没有被定义，而在其后方才被定义为宏，于是只有<code>b</code>的赋值语句中 <code>N</code> 被正确展开成了 <code>3</code>。</p><p>  <code>C/C++</code>预处理器在处理宏时的展开过程。<u>当宏体中出现宏的调用（即宏名的使用）时，预处理器会将展开后的宏体中的宏继续展开</u>。这个过程是<strong>递归</strong>的，直到所有的宏都被替换为它们的值或者代码片段。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABLESIZE BUFFERSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 1024</span><br></code></pre></td></tr></table></figure><p>那么实际上，<code>TABLESIZE</code> 首先被展开成 <code>BUFSIZE</code>，然后 <code>BUFSIZE</code> 又被展开为 <code>4</code>，所以最终的效果是使用 <code>TABLESIZE</code> 的地方都被展开成了 <code>4</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">TABLESIZE <br>    -&gt; BUFSIZE<br>    -&gt; <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>  注意，在定义 <code>TABLESIZE</code> 时没有定义 <code>BUFSIZE</code>。<code>TABLESIZE</code> 的<code>#define</code>完全使用指定的展开式，因为不会进行语法检查，并且不检查它是否也包含宏名称。只有当您使用 <code>TABLESIZE</code> 时，才会扫描其展开的结果以查找更多的宏名称，因为使用 <code>TABLESIZE</code> 之处也处于 <code>BUFSIZE</code> 作用域之内。这也说明了，宏指令的位置与最终展开的结果相关，预处理最终将会使用当前生效的宏进行展开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABLESIZE BUFSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> BUFSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 37</span><br></code></pre></td></tr></table></figure><p>这个示例中，<code>TABLESIZE</code> 最终被展开为了 <code>37</code>。</p><p>  还有一种情况：如果宏体中包含自身的宏名称(直接或通过中间宏) ，<u>则在检查更多宏时不再展开。这可以防止无限递归</u>。下面是一个例子来说明这种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO FOO</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>FOO</code> 宏被定义为它自己。当预处理器遇到 <code>FOO</code> 时，它会尝试展开 <code>FOO</code>，但发现 <code>FOO</code> 的定义就是它自己，所以预处理器不会再次展开 <code>FOO</code>，避免了无限递归。</p><p>另一个更复杂的例子，涉及中间宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BAR FOO</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO BAR</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>FOO</code> 被定义为 <code>BAR</code>，而 <code>BAR</code> 被定义为 <code>FOO</code>。如果预处理器尝试展开 <code>FOO</code>，它会被替换为 <code>BAR</code>，然后 <code>BAR</code> 又会尝试展开为 <code>FOO</code>，但此时预处理器已经知道 <code>FOO</code> 会展开为 <code>BAR</code>，所以它不会再次展开 <code>FOO</code>，避免了无限递归。</p><p>在这两种情况下，预处理器都会停止进一步展开宏，以防止无限递归的发生。这种自我引用的宏定义通常不是有意为之的，因为它们不会产生有用的结果，但它们确实展示了预处理器如何处理宏的递归展开，这部分将在后续 <code>自引用宏章节</code> 介绍。</p><h3 id="类函数宏-Function-like-Macros">类函数宏(Function-like Macros)</h3><p>  实际上，还可以定义<strong>看起来像函数调用的宏</strong>。这些被称为<strong>类函数宏</strong>。要定义一个类似函数的宏，同样使用 <code>#define</code>指令，但在<u>宏名称后紧接一对括号</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lang_init()  c_init()</span><br><br><span class="hljs-comment">// 预处理后</span><br><span class="hljs-built_in">lang_init</span>()<br>     -&gt; <span class="hljs-built_in">c_init</span>()<br></code></pre></td></tr></table></figure><p>当定义了一个类函数宏时，只有当这个宏的名字后面紧跟着一对括号时，它才会被展开。<u>如果宏的名字后面没有括号，那么它就不会被展开，而是保持原样</u>。这在存在同名的<strong>函数</strong>和<strong>类函数宏</strong>时，希望调用真实函数而不是宏时进行区分很有用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo() <span class="hljs-comment">/* optimized inline version */</span></span><br>...<br><span class="hljs-built_in">foo</span>();<br>funcptr = foo;<br></code></pre></td></tr></table></figure><p>这里对 <code>foo()</code> 的调用将使用<strong>宏</strong>，而函数指针 <code>funcptr</code> 获取的是<strong>函数</strong><code>foo</code> 的地址。但是这里如果将 <code>foo()</code> 进行展开将会出现语法错误……</p><p>  如果在宏定义中的宏名称和括号之间放置空格，则不是类函数宏，而是定义了一个类对象宏，其扩展恰好以一对括号开始：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lang_init ()  c_init()</span><br><br><span class="hljs-comment">// 预处理后</span><br><span class="hljs-built_in">lang_init</span>()<br>     -&gt; ()  <span class="hljs-built_in">c_init</span>()()<br></code></pre></td></tr></table></figure><p>需要注意。</p><!-- [官方文档](https://gcc.gnu.org/onlinedocs/cpp/Macros.html) -->]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Cpp</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试博客功能</title>
    <link href="/2024/11/16/test/"/>
    <url>/2024/11/16/test/</url>
    
    <content type="html"><![CDATA[<h1>线性代数——二次型</h1><h2 id="一、二次型的定义及其矩阵表达式">一、二次型的定义及其矩阵表达式</h2><p>  $n$ 元变量 $x_1$，$x_2$，…，$x_n$ 的二次齐次多项式</p><p>$$f(x_1, x_2, …, x_n) = a_{11}x_1^2+2a_{12}x_1x_2+…+2a_{1n}x_1x_n\+a_{22}x_2^2+2a_{23}x_2x_3+…+2a_{2n}x_2x_n\+…+a_{nm}x_n^2$$</p><p>称为 $n$ <strong>元二次型</strong>，简称<strong>二次型</strong>.</p><p>  这里只介绍系数 $a_{ij} \in R(i \le j; i,j = 1, 2, …, n)$的情况，称此二次型 $f$ 为<strong>实二次型</strong>.</p><p>  因为 $x_ix_j = x_jx_i$，于是令 $a_{ij} = a_{ji}(i,j = 1, 2, …, n)$，则 $2a_{ij}x_ix_j = a_{ij}x_ix_j+a_{ji}x_jx_i$，于是令</p><p>$$<br>A = \begin{pmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}<br>\end{pmatrix}$$</p><p>$$x = \begin{pmatrix}<br>x_{1} \<br>x_{2} \<br>\vdots \<br>x_{n} \<br>\end{pmatrix}$$</p><p>则二次型可以表示为</p><p>$$f(x) = x^TAx$$</p><p>其中，<strong>实对称矩阵</strong>$A$称为<strong>二次型</strong>$f(x)$<strong>的矩阵</strong>. 这里 $A$ 是一个对称矩阵，$A_{ij} = (a_{ij}), a_{ij} = a_{ji}$，即满足 $A^T = A$. 实际上二次型可以有多种写法，如：<br>$$f(x) = x_1^2+x_2^2+4x_1x_2$$<br>或<br>$$f(x) = x_1^2+x_2^2+1x_1x_2+3x_2x1$$</p><p>于是对应的矩阵 $A$ 分别为：<br>$$<br>A = \begin{pmatrix}<br>1 &amp; 2  \<br>2 &amp; 1 \<br>\end{pmatrix}$$</p><p>和</p><p>$$<br>A = \begin{pmatrix}<br>1 &amp; 1  \<br>3 &amp; 1 \<br>\end{pmatrix}$$</p><p>而这里作了规定，<strong>二次型的矩阵必须为对称矩阵</strong>，那么如此代表二次型的矩阵就是<strong>唯一</strong>的了.</p><h2 id="二、合同变换，二次型的合同标准型、规范型">二、合同变换，二次型的合同标准型、规范型</h2><h3 id="1-线性变换的定义">1.线性变换的定义</h3><p>  对于 $n$元二次型 $f(x_1, x_2, …, x_n)$，若令</p><p>$$ \left{<br>\begin{aligned}<br>x_1 &amp;= c_{11}y_1 + c_{12}y_2 + \cdots + c_{1n}y_n \<br>x_2 &amp;= c_{21}y_1 + c_{22}y_2 + \cdots + c_{2n}y_n \<br>&amp;\vdots \<br>x_n &amp;= c_{n1}y_1 + c_{n2}y_2 + \cdots + c_{nn}y_n<br>\end{aligned}<br>\right.<br>$$</p><p>记<br>$$x = \begin{pmatrix}<br>x_{1} \<br>x_{2} \<br>\vdots \<br>x_{n} \<br>\end{pmatrix}$$</p><p>$$<br>C = \begin{pmatrix}<br>c_{11} &amp; c_{12} &amp; \cdots &amp; c_{1n} \<br>c_{21} &amp; c_{22} &amp; \cdots &amp; c_{2n} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>c_{n1} &amp; c_{n2} &amp; \cdots &amp; c_{nn}<br>\end{pmatrix}$$</p><p>$$y = \begin{pmatrix}<br>y_{1} \<br>y_{2} \<br>\vdots \<br>y_{n} \<br>\end{pmatrix}$$</p><p>则，上式可以写为：</p><p>$$x = Cy$$<br>上述变换称为<strong>线性变换</strong>，若线性变换的系数矩阵$C$可逆，即 $|C| \ne 0$，则称为<strong>可逆线性变换</strong>. 现给出：<br>$$f(x) = x^TAx$$<br>令 $x = Cy$，则<br>$$f(x) = (Cy)^TA(Cy) = y^T(C^TAC)y$$<br>记 $B = C^TAC$，则<br>$$f(x) = y^TBy = g(y)$$<br>显然，这又是一个新的二次型：即二次型 $f(x)=x^TAx$通过线性变换 $x=Cy$ 得到了一个新的二次型 $g(y) = y^TBy$</p><p><img src="/img/in_posts/blog_start/changli.jpg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
      <tag>latex</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇个人博客</title>
    <link href="/2024/11/15/first-blog/"/>
    <url>/2024/11/15/first-blog/</url>
    
    <content type="html"><![CDATA[<h3 id="开始的地方">开始的地方</h3><p>  Hi everyone. I’m HiJackiee and this is my first personal blog!</p><p><img src="/img/in_posts/blog_start/changli.png" alt="和光同尘，与时舒卷."></p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>introduction</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
