<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（三）</title>
    <link href="/2024/12/24/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_3/"/>
    <url>/2024/12/24/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_3/</url>
    
    <content type="html"><![CDATA[<h2 id="连接concatenation">连接[Concatenation]</h2><p>  在拓展宏时，将两个标记合并成一个标记通常很有用。而这个过程被称为<strong>标记连接</strong><span class="math inline">\(token \concatenation\)</span>（或称<strong>标记粘贴</strong> <spanclass="math inline">\(token\ pasting\)</span>），这是通过<code>##</code>预处理运算符实现的。宏进行展开时，在<code>##</code>运算符两侧的标记会被合并成为一个标记，而<code>##</code>运算符本身会被删去。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE(x, y) x ## y</span><br><br><span class="hljs-built_in">PASTE</span>(My, Class)<br><br><span class="hljs-comment">// 预处理之后</span><br>MyClass<br></code></pre></td></tr></table></figure><h3 id="合法的标记">合法的标记</h3><p>  那么 <code>##</code>两侧可以放置的合法的标记有哪些呢？一下是一些合法的标记：</p><ol type="1"><li>标识符（<code>Identifiers</code>）：合法的 <code>C/C++</code>标识符，例如变量名、函数名等；</li><li>预处理数字（<code>Preprocessing Numbers</code>）：预处理器识别的数字，包括整数和浮点数；</li><li>字符串字面量（<code>String Literals</code>）：用双引号括起来的字符串；</li><li>宏参数（<code>Macro Parameters</code>）：宏定义中使用的参数；</li><li>宏（<code>Macros</code>）：已经定义过的宏；</li><li>关键字（<code>Keywords</code>）：<code>C\C++</code> 中的关键字，比如<code>int</code>、<code>if</code>等；</li><li>操作符和分隔符（<code>Operators and Separators</code>）：如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>等；</li><li>空标记（<code>Empty Tokens</code>）：在某些情况下，空标记也是合法的，例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONCAT(a, b) a ## b</span><br><span class="hljs-built_in">CONCAT</span>(, foo)<br><br><span class="hljs-comment">// 预处理展开后：</span><br>foo<br></code></pre></td></tr></table></figure></li><li>多字符操作符（<code>Multi-Character Operators</code>）：例如<code>+=</code>、<code>-&gt;</code> 等；</li></ol><blockquote><p>并非所有的标记都可以使用 <code>##</code>操作符进行连接。如果两个标记连接后不能形成一个有效的标记，那么预处理器将不会尝试将它们合并，而是会发出警告，并输出这两个标记。这里的有效的标记就是上面罗列的合法的标记。例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONCAT(a, b) a ## b</span><br><span class="hljs-built_in">CONCAT</span>(x, +)<br></code></pre></td></tr></table></figure> <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">// g++ -E -o main.i main.cpp<br>main.cpp:3:8: error: pasting &quot;x&quot; and &quot;+&quot; does not give a valid preprocessing token<br>   3 | CONCAT(x, +)<br>     |        ^<br>main.cpp:1:22: note: in definition of macro &#x27;CONCAT&#x27;<br>   1 | #define CONCAT(a, b) a ## b<br>     |                      ^<br></code></pre></td></tr></table></figure> 可以看到，报错信息已经很显然了</p></blockquote><p>  需要注意的是， * 注释会转换为空白在宏处理之前，预处理器会将注释转换为空白字符。这就意味着不能通过连接<code>/</code> 和 <code>*</code>来创建一个注释，注释在预处理阶段就会被移除；</p><ul><li><p><code>##</code> 周围的空白 实际上可以在 <code>##</code>操作符和其操作数之间放置任意数量的空白字符，包括空格、制表符和换行符等，这类空白字符在预处理时都会被忽略；</p></li><li><p><code>##</code> 操作数和注释可以在将要被连接的参数中放置注释，因为注释会被转换为空白字符，所以最终会被<code>##</code> 处理时忽略；</p></li><li><p><code>##</code> 操作数的位置错误 <code>##</code>操作数不能出现在宏体的开头或者结尾：也就是说，<code>##</code>操作数的两侧必须有标记，当然传入宏参数时可以传入空白标记。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE(a, b) a ## b</span><br><br><span class="hljs-comment">// 正确使用，参数之间有注释</span><br><span class="hljs-built_in">PASTE</span>(a <span class="hljs-comment">/* comment */</span> , b)  <span class="hljs-comment">// 展开为 ab</span><br><br><span class="hljs-comment">// 错误使用，## 出现在宏的开始</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVALID_MACRO1 ##a  <span class="hljs-comment">// 错误，## 没有操作数</span></span><br><br><span class="hljs-comment">// 错误使用，## 出现在宏的结束</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVALID_MACRO2 a##  <span class="hljs-comment">// 错误，## 没有操作数</span></span><br></code></pre></td></tr></table></figure><h3 id="实际的例子">实际的例子</h3><p>  下面是一个运用宏连接使得代码更简洁的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">command</span>&#123;<br>    <span class="hljs-type">char</span>* name;<br>    <span class="hljs-built_in">void</span> (*function) (<span class="hljs-type">void</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">command</span> commands[] = &#123;<br>    &#123;<span class="hljs-string">&quot;quit&quot;</span>, quit_command&#125;,<br>    &#123;<span class="hljs-string">&quot;help&quot;</span>, help_command&#125;,<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>使用宏连接后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMAND(NAME) &#123;#NAME, NAME ## _command&#125;</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">command</span> commands[] = &#123;<br>    <span class="hljs-built_in">COMMAND</span>(quit),<br>    <span class="hljs-built_in">COMMAND</span>(help),<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>  这里分别使用宏<strong>字符串化</strong>和宏<strong>连接</strong>。</p><h2 id="可变参数宏variadic-macros">可变参数宏[Variadic Macros]</h2><p>  和函数一样，宏也可以在声明时接受一个可变数量的参数，语法也与函数定义相似。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> eprintf(...) fprintf(stderr, __VA_ARGS__)</span><br></code></pre></td></tr></table></figure><p>  这样的宏被称为<strong>可变参数宏</strong>。当可变参数宏被调用时，<u>所有在最后一个命名参数之后传递给宏的参数（在这个例子中，宏没有命名参数）都被视为可变参数部分</u>。这意味着，<u>包括任何逗号在内的所有标记（tokens）都被视为可变参数</u>。</p><p>  在宏体内，<code>__VA_ARGS__</code>是一个特殊的标识符，用来表示传递给宏的所有可变参数。当宏展开时，<code>__VA_ARGS__</code>会被替换为宏调用中传递的所有实际参数。在宏展开过程中，<code>__VA_ARGS__</code>将被替换为宏调用中提供的实际参数序列。这意味着，宏调用中的参数将直接替换宏定义中的<code>__VA_ARGS__</code>，包括所有的逗号和标记。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(...) printf(__VA_ARGS__)</span><br><br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><br><span class="hljs-comment">// 预处理展开后：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>); <span class="hljs-comment">// 可以看到，逗号也作为可变参数的一部分</span><br></code></pre></td></tr></table></figure><ol type="1"><li>可变参数中的宏  在可变参数被插入到宏展开中之前，它们会像普通参数一样被完全宏展开。也就是说，如果可变参数中包含宏，这些宏会在被传递到可变参数之前被展开。如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(...) printf(__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FMT <span class="hljs-string">&quot;Hello, %s!\n&quot;</span></span><br><br><span class="hljs-built_in">LOG</span>(FMT, <span class="hljs-string">&quot;world&quot;</span>);<br><br><span class="hljs-comment">// 预处理展开后：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>字符串化可变参数（#）   同样可以使用 <code>#</code>操作符来字符串化可变参数，这样可以将可变参数转化为字符串字面量。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGIFY(...) #__VA_ARGS__</span><br><br><span class="hljs-built_in">STRINGIFY</span>(some text)<br><br><span class="hljs-comment">// 预处理展开后：</span><br><span class="hljs-string">&quot;some text&quot;</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>使用 <code>##</code> 操作符   实际上，使用 <code>##</code>操作符将可变参数的首位标记与其他标记连接在一起也是允许的，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br><br><span class="hljs-built_in">PASTE_PREFIX</span>(MY_, function)<br><br><span class="hljs-comment">// 预处理展开后：</span><br>MY_function<br></code></pre></td></tr></table></figure><p>  需要注意的是，当使用 <code>##</code>连接可变参数时，如果可变参数本身为空，那么对应连接的空白标记的情况，这个时候<code>##</code> 操作符不会有任何效果。</p><p><br><br><br><br></p><p>  如果宏很复杂，那么可能希望变量参数有一个比<code>__VA_ARGS__</code>更具描述性的名称。<code>CPP</code>允许这样，作为一种扩展。可以立即在<code>...</code>前面写入一个参数名称；该名称用于变量参数。可以编写上面的<code>eprintf</code>宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> eprintf(args...) fprintf(stderr, args)</span><br></code></pre></td></tr></table></figure><p>需要注意的是，使用了拓展名之后，不能在同一个宏中同时使用拓展名和<code>__VA_ARGS__</code>。</p><p>  就如前面的例子，在一个可变参数宏中既可以存在命名参数和可变参数，如上面的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br></code></pre></td></tr></table></figure><p>但这实际上存在一个可能的问题——当此时可变参数为空时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br><br><span class="hljs-built_in">PASTE_PREFIXZ</span>(MY_, )<br></code></pre></td></tr></table></figure><p>在 <code>C++20</code> 以前，<code>PASTE_PREFIXZ(MY_, )</code> 中的<code>,</code> 被视为可变参数的一部分，所以最终展开的结果是<code>MY_,</code>，这与我们的预期不符。这个问题在 <code>C++20</code>后已经被解决了——实际上我们已经可以完全忽略可变参数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br><br><span class="hljs-built_in">PASTE_PREFIXZ</span>(MY_) <span class="hljs-comment">// 这里逗号都可以不要</span><br></code></pre></td></tr></table></figure><p>  其次，<code>C++20</code>引入了<code>__VA_OPT__</code>函数宏。此宏可能<u>只出现在可变参数宏的定义中</u>。它提供了一种条件展开机制，允许开发者根据可变参数是否存在来决定是否展开某些代码。其工作原理：</p><ol type="1"><li>条件展开<ul><li><code>__VA_OPT__</code>宏函数检查可变参数（<code>variable argument</code>）是否有任何标记（<code>tokens</code>）；</li><li>如果可变参数中包含至少一个标记，那么<code>__VA_OPT__</code>会将其参数展开为这些标记；</li><li>如果可变参数中不包含任何标记（即为空），那么<code>__VA_OPT__</code>展开为空，不会产生任何代码。</li></ul></li><li>语法<ul><li><code>__VA_OPT__</code>的使用语法是<code>__VA_OPT__(参数)</code>，其中参数是当可变参数非空时应该展开的代码；</li><li>常用：<code>__VA_OPT__(op1, op2)</code>：其中 <code>op1</code>对应可变参数中不包含任何标记时的操作，<code>op2</code>对应可变参数中包含标记时的操作。<code>op1</code>通常为空，使得当可变参数中不包含任何标记时展开为空。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(msg, ...) printf(<span class="hljs-string">&quot;Log: &quot;</span> msg <span class="hljs-string">&quot;\n&quot;</span> __VA_OPT__(, ##__VA_ARGS__) )</span><br><br><span class="hljs-comment">// 调用示例</span><br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;This is a message&quot;</span>);<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;This is a message&quot;</span>, <span class="hljs-string">&quot; with additional info&quot;</span>);<br><br><span class="hljs-comment">// 预处理之后：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Log: This is a message\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Log: This is a message, with additional info\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中： -<code>LOG</code>宏定义了一个可变参数宏，其中使用了<code>__VA_OPT__</code>；-当只有<code>msg</code>参数被提供时，<code>__VA_ARGS__</code>为空，<code>__VA_OPT__(, ##__VA_ARGS__)</code>展开为空，因此没有额外的代码被添加；-当提供了额外的参数时，<code>__VA_ARGS__</code>非空，<code>__VA_OPT__(, ##__VA_ARGS__)</code>展开为,<code>##__VA_ARGS__</code>，这允许<code>printf</code>函数接受额外的参数。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Cpp</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（二）</title>
    <link href="/2024/11/20/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_2/"/>
    <url>/2024/11/20/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_2/</url>
    
    <content type="html"><![CDATA[<h2 id="一宏参数">一、宏参数</h2><p>  和真正的函数一样，类函数宏也<strong>可以接受参数</strong>。类函数宏需要参数时，你需要将参数插入圆括号<code>()</code>中，这和调用函数时一样(函数声明和定义时需要指明参数类型，宏是文本替换，所以不需要提供参数类型信息)。需要注意的是，宏参数须为有效的<code>C/C++</code>标识符，并且在<strong>存在多个参数时使用逗号隔开，以及可选的空格</strong>。</p><h3 id="调用宏的方式">1.1 调用宏的方式</h3><p>  当想要使用一个带有参数的宏时，宏名称后接一对圆括号<code>()</code>，并且<strong>在括号内插入实际的参数列表，参数列表用逗号隔开</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) ((a) &gt; (b)? (a): (b))</span><br><br><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="宏调用可以跨多行">1.2 宏调用可以跨多行</h3><p>  宏的调用不必限制在源文件的单行内，它<strong>可以跨越多行</strong>。这意味着你可以在调用宏时，在参数列表中使用换行符，以提高代码的可读性。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<br>    a + b,<br>    c + d<br>);<br></code></pre></td></tr></table></figure><p>因为上一节讲过，所有宏都会被展开成源代码中的一行。</p><h3 id="参数数量必须匹配">1.3 参数数量必须匹配</h3><p>  当然，在调用宏时<strong>提供的参数数量必须与宏定义中的参数数量相匹配</strong>。如果宏定义了两个参数，调用时也必须提供两个参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><h3 id="宏展开时参数的替换">1.4 宏展开时参数的替换</h3><p>  当宏被展开时，<strong>宏体</strong>中的每个参数都会被对应的实际参数替换。这里的<strong>替换</strong>指的是<u>将宏定义中的参数名称替换为实际参数的代码</u>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) ((a) &gt; (b)? (a): (b))</span><br><br><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = ((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><h3 id="参数的使用是可选的">1.5 参数的使用是可选的</h3><p>  <strong>宏中定义的参数的使用是可选的</strong>，宏体定义的参数不一定要在宏体中使用。可以定义一个参数，但在宏体中不使用它，或者只使用部分参数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_LOG(x, y) printf(<span class="hljs-string">&quot;Value of x: %d\n&quot;</span>, x)</span><br></code></pre></td></tr></table></figure><h3 id="宏调用时参数的处理规则">1.6 宏调用时参数的处理规则</h3><h4 id="参数前后的空白字符被丢弃">1. 参数前后的空白字符被丢弃</h4><p>  在宏调用中，每个参数前后的空白字符（空格、制表符等）都会被丢弃。这意味着，无论实际参数前后有多少空白字符，它们都不会出现在宏展开后的代码中。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(    <span class="hljs-number">2</span>    ,    <span class="hljs-number">3</span>    );<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = ((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>可以看到，参数 <code>2</code>和<code>3</code>前后的空白字符都被丢弃。</p><h4 id="参数内部的空白字符被压缩为单个空格">2.参数内部的空白字符被压缩为单个空格</h4><p>  在参数内部，所有的空白字符（包括空格、制表符等）都会被压缩为单个空格。这意味着，无论参数内部有多少连续的空白字符，它们都会被替换为一个空格。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span> +    <span class="hljs-number">4</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = ((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span> + <span class="hljs-number">4</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span> + <span class="hljs-number">4</span>));<br></code></pre></td></tr></table></figure><p>参数<code>3 +    4</code>中的多个空白字符被压缩成了一个空格。</p><h4 id="参数内的括号必须平衡">3. 参数内的括号必须平衡</h4><p>  在参数内部，如果使用了圆括号，那么这些圆括号必须平衡（即每对开括号(必须有对应的闭括号)）。<u>在平衡的圆括号内部的逗号不会导致参数的结束，简单理解就是圆括号中的逗号不会将其分隔成不同参数</u>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = (((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) &gt; (<span class="hljs-number">3</span>)? ((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>且不论上述宏展开后的代码是否合法（实际上宏展开也不会进行语法检查），参数<code>(2, 3)</code>并没有被分隔成两个参数<code>(2</code> 和 <code>3)</code>。所以说，圆括号务必要平衡。</p><h4 id="方括号和花括号不需要平衡">4. 方括号和花括号不需要平衡</h4><p>  对于方括号<code>[]</code>和花括号<code>&#123;&#125;</code>，不需要平衡，其内部的逗号仍然会被视为参数分隔符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">3</span>); <span class="hljs-comment">// 三个参数 [2、3] 和 3</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-number">3</span>); <span class="hljs-comment">// 三个参数 &#123;2、3&#125; 和 3</span><br></code></pre></td></tr></table></figure><p>这里<strong>实际上是无法进行宏展开的</strong>，会导致编译错误，因为宏定义时只接受两个参数，而这里提供了三个参数。</p><h3 id="宏参数的展开规则">1.7 宏参数的展开规则</h3><ol type="1"><li><p>宏参数的完全展开  <u>在宏体中替换参数之前，所有传递给宏的实际参数都会先进行完全的宏展开</u>。这意味着，如果实际参数本身是一个宏，或者包含宏，那么这些宏会首先被展开。</p></li><li><p>替换后的再次扫描  替换参数到宏体之后，整个宏体（包括替换后的参数）会再次被扫描，以查找是否有更多的宏需要展开。这个过程会持续进行，直到没有更多的宏可以展开。</p></li></ol><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>第一次，参数进行展开： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>), <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></p><p>第二次，替换后的再次扫描： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = ((((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>))) &gt; (<span class="hljs-number">3</span>)? (((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>))): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure></p><p>事实上，你甚至在为宏传递空参数，例如： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = (() &gt; (<span class="hljs-number">3</span>)? (): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure></p><p>但是在传空参数时仍然要确保参数的匹配。</p><p>  需要注意的是：出现在<strong>字符串中的宏参数不会被它们相应的实际参数替换</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo(x) x, <span class="hljs-string">&quot;x&quot;</span></span><br><br><span class="hljs-comment">// 实际调用</span><br><span class="hljs-built_in">foo</span>(bar)<br><br><span class="hljs-comment">// 预处理展开后</span><br>bar, <span class="hljs-string">&quot;x&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>到这里，你一定会疑惑，为什么我们在宏定义时，宏体中的参数都会包裹在一对圆括号内</p></blockquote><h3 id="宏体参数用圆括号包裹的原因">1.8 宏体参数用圆括号包裹的原因</h3><h4 id="操作符优先级">1. 操作符优先级：</h4><p>  在C/C++中，宏参数可能会与宏体中的其他代码一起参与运算。如果不使用括号，可能会因为操作符优先级的问题导致宏的展开结果与预期不符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) x * x</span><br></code></pre></td></tr></table></figure><p>  如果你使用<code>SQUARE(a + b)</code>，宏会展开为<code>a + b * a + b</code>，这显然不是我们想要的结果，因为按照乘法优先于加法的规则，它实际上变成了<code>a + (b * a) + b</code>。正确的结果应该是<code>(a + b) * (a + b)</code>。</p><h4 id="使用括号可以确保参数作为一个整体被处理">2.使用括号可以确保参数作为一个整体被处理：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) (x) * (x)</span><br></code></pre></td></tr></table></figure><p>  这样，<code>SQUARE(a + b)</code>会正确展开为<code>(a + b) * (a + b)</code>。</p><h4 id="避免宏参数为空">3. 避免宏参数为空：</h4><p>  如果宏的参数可能为空（例如，在宏定义中使用<code>##</code>运算符进行连接时），不使用括号可能会导致编译错误。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EMPTY()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GLUE(x, y) x ## y</span><br><br><span class="hljs-built_in">GLUE</span>(EMPTY, <span class="hljs-type">int</span>) var; <span class="hljs-comment">// 这将尝试定义一个名为&quot;int&quot;的变量，而不是&quot;Emptyint&quot;</span><br></code></pre></td></tr></table></figure><p>  如果<code>EMPTY</code>宏没有括号，<code>GLUE(EMPTY, int)</code>将尝试将<code>EMPTY</code>和<code>int</code>连接起来，而不是将<code>EMPTY()</code>作为一个整体与<code>int</code>连接。</p><h4 id="参数可能包含多个标记">4. 参数可能包含多个标记：</h4><p>  如果宏参数本身是一个复合表达式或多个标记，那么使用括号可以确保整个表达式被正确处理。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE_AND_INCREMENT(x) ((x) * (x)) + 1</span><br></code></pre></td></tr></table></figure><p>  这里，<code>(x)</code>确保了<code>x</code>的整个表达式被乘以自身，然后再加<code>1</code>。</p><h4 id="提高代码的可读性和一致性">5. 提高代码的可读性和一致性：</h4><p>  使用括号可以使宏的定义更加清晰，让阅读代码的人更容易理解宏的意图和行为。</p><h2 id="二字符串化">二、字符串化</h2><p>  预处理器中的字符串化（<code>Stringizing</code>）操作。这是一种将宏参数转换为字符串常量的技术。有时可能希望将宏参数转换为字符串常量。<u>在字符串常量中，参数不会被替换，但是可以使用<code>#</code>预处理操作符来实现这一点</u>。</p><h3 id="操作符的使用">2.1 #操作符的使用</h3><p>  当宏参数前面有一个<code>#</code>操作符时，预处理器会用实际参数的文本内容替换它，并将其转换为字符串常量。这与普通的参数替换不同，因为参数不会首先被宏展开。</p><p>  字符串化操作<u>不会在参数替换之前对参数进行宏展开</u>。这意味着如果参数是一个宏，它不会被展开，而是直接将其名称作为字符串插入。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING hello</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGFY(Argu) #Argu</span><br><br><span class="hljs-built_in">STRINGFY</span>(STRING)<br></code></pre></td></tr></table></figure><p>预处理展开之后： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;STRING&quot;</span><br></code></pre></td></tr></table></figure>可以看到，宏<code>STRINGFY</code>的参数也是一个宏<code>STRING</code>，但并没有被展开为<code>hello</code>，而是直接将其名称字符串化为了字符串常量<code>"STRING"</code>。</p><p>  不能直接将参数与周围的文本组合在一起并一次性字符串化。相反，你可以编写一系列相邻的字符串常量和字符串化的参数。预处理器会将字符串化的参数替换为字符串常量，然后，编译器会将所有相邻的字符串常量合并为一个长字符串。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> WARN_IF(EXP) \</span><br><span class="hljs-meta">do &#123; <span class="hljs-keyword">if</span> (EXP) \</span><br><span class="hljs-meta">        fprintf (stderr, <span class="hljs-string">&quot;Warning: &quot;</span> #EXP <span class="hljs-string">&quot;\n&quot;</span>); &#125; \</span><br><span class="hljs-meta">while (0)</span><br><span class="hljs-built_in">WARN_IF</span> (x == <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>预处理器展开后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span> &#123; <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) \<br>    <span class="hljs-built_in">fprintf</span> (stderr, <span class="hljs-string">&quot;Warning: &quot;</span> <span class="hljs-string">&quot;x == 0&quot;</span> <span class="hljs-string">&quot;\n&quot;</span>); \<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>注意，这里的<code>\</code>表示行间是连接的，因为宏展开会成一行，这里为了方便，增加了换行。可以看到，<code>EXP</code>的参数被替换为 <code>if</code> 语句中的条件参数和 <code>fprintf</code>参数中的 <code>string</code> 参数。<u>如果 <code>x</code>是一个宏，它将在 <code>If</code>语句中展开，但不会在字符串中展开</u>。后面的几个字符串常量<code>"Warning: " "x == 0" "\n"</code>会在编译器的帮助下合并成一个字符串常量。</p><blockquote><p>这里其实还提到了 <code>do...while(0)</code>循环的使用，这是一种技巧，将在后续章节探讨。</p></blockquote><p>  可见，字符串化不仅仅是在宏参数周围添加双引号那么简单。预处理器会进行额外的处理，以确保生成的字符串常量是有效的，并且包含正确的内容。</p><h3 id="宏参数字符串化的细节处理">2.2 宏参数字符串化的细节处理</h3><h4 id="预处理器对引号和反斜杠的处理">1.预处理器对引号和反斜杠的处理</h4><p>  当宏参数中包含字符串常量时，预处理器会对其进行转义处理。这意味着，如果宏参数中包含双引号或反斜杠，预处理器会在它们前面添加反斜杠来进行转义。这样做的目的是为了确保生成的字符串常量在<code>C/C++</code>语言中是有效的。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGFY(Argu) #Argu</span><br><br><span class="hljs-built_in">STRINGFY</span>(<span class="hljs-string">&quot;hello\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>预处理器展开后： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;\&quot;hello\\n\&quot;&quot;</span><br></code></pre></td></tr></table></figure></p><h4 id="非字符串或字符常量中的反斜杠不加倍">2.非字符串或字符常量中的反斜杠不加倍</h4><p>  如果反斜杠不在字符串或字符常量中，它们不会被加倍。例如，<code>\n</code>单独字符串化时，结果就是<code>"\n"</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGFY(Argu) #Argu</span><br><br><span class="hljs-built_in">STRINGFY</span>(\n)<br></code></pre></td></tr></table></figure><p>预处理器展开后： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;\n&quot;</span><br></code></pre></td></tr></table></figure></p><h4 id="字符串化中的空白处理">3. 字符串化中的空白处理</h4><p>  在字符串化过程中，宏参数中的所有前导和尾随空白都会被忽略。文本中的任何空白序列（空格、制表符等）在字符串化结果中会被转换为单个空格。其实也是一种特殊的宏参数处理。</p><h4 id="无法将宏参数转换为字符常量">4. 无法将宏参数转换为字符常量</h4><p>  没有办法将宏参数直接转换为字符常量。这是因为字符常量在<code>C/C++</code>语言中是用单引号括起来的单个字符，而字符串化操作是将整个宏参数转换为双引号括起来的字符串常量。</p><h3 id="如何字符串化宏参数的展开">2.3 如何字符串化宏参数的展开</h3><p>  如果要将<strong>宏参数展开后的结果转换成字符串常量</strong>，则需要使用<strong>两级宏</strong>（即<strong>嵌套宏</strong>）来实现。这是因为在预处理阶段，<u>宏参数首先被展开，然后才进行字符串化</u>。如果直接在宏中使用<code>#</code>操作符来字符串化宏参数，那么字符串化的是宏参数本身，而不是它展开后的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xstr(s) str(s)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> str(s) #s</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo 4</span><br><br><span class="hljs-built_in">xstr</span> (foo)<br></code></pre></td></tr></table></figure><p>第一次展开： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">xstr</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// 第一次展开并非字符串化，故参数会展开</span><br></code></pre></td></tr></table></figure></p><p>第二次展开： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">str</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// 第二次展开是 xstr 展开</span><br></code></pre></td></tr></table></figure></p><p>然后字符串化： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;4&quot;</span> <span class="hljs-comment">// 最后是字符串化</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Cpp</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（一）</title>
    <link href="/2024/11/18/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_1/"/>
    <url>/2024/11/18/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_1/</url>
    
    <content type="html"><![CDATA[<h3 id="宏是什么">宏是什么？</h3><p>  <strong>宏</strong>(<code>Macros</code>)是一段代码片段，每个<strong>宏</strong>被赋予了一个名称。<strong>无论何时使用该名称，都将由宏的内容替换</strong>（其实就是文本替换）。宏有两种——<strong>类对象宏(<code>Object-like Macros</code>)</strong>和<strong>类函数宏(<code>Function-like Macros</code>)</strong>。它们的差异主要体现在使用时，使用<strong>类对象宏</strong>时类似于数据对象，使用<strong>类函数宏</strong>时类似于函数调用。</p><p><span class="math display">\[宏\begin{cases}类对象宏 \\\\类函数宏\end{cases}\]</span></p><h3 id="类对象宏object-like-macros">类对象宏(Object-like Macros)</h3><p>  <strong>类对象宏</strong>其实就是一个简单的<strong>标识符</strong>，其在代码中被使用之处会被其所指的代码片段给替换。之所以将其称为<strong>类对象宏</strong>，是因为在代码中使用<strong>类对象宏</strong>时就像在使用普通的数据对象一样。通常的<u>使用场景是给数值常量赋予符号名称</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 示例1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14</span><br></code></pre></td></tr></table></figure><p>  <u>在<code>C/C++</code>中，宏是通过预处理指令<code>#define</code>来创建的</u>。这个指令告诉预处理器定义一个新的宏（预处理器是C/C++编译过程中的一个阶段，负责处理源代码中的预处理指令，如宏定义、文件包含和条件编译等）。</p><p>  <code>#define</code>后面紧跟的是宏的<strong>名称</strong>。宏的名称<strong>通常以大写字母表示</strong>，以区分于变量和其他标识符，这是一种约定俗成的命名习惯，有助于提高代码的可读性。</p><p>  宏名称之后是宏的<strong>替换列表(replacementlist)</strong>，也就是<u>当宏被使用时，预处理器将宏名称替换为这个列表中的代码</u>。这个替换列表有时被称为宏的“<strong>体</strong>”(<code>body</code>)、“<strong>展开</strong>”(<code>expansion</code>)。</p><blockquote><p>需要注意得是，宏定义后没有分号！本质上宏是一种预编译指令，并不是<code>C/C++</code>得一条语句，所以没有分号。</p></blockquote><p>  示例1中定义了一个名为 <code>PI</code>的宏表示圆周率，其对应的<strong>宏体</strong>为我们希望圆周率所取得的数值<code>3.14</code>。如果在 <code>define</code>语句之后，某个代码位置使用了这个宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> perimeter = <span class="hljs-number">2</span>*PI;<br></code></pre></td></tr></table></figure><p>然后 <code>C/C++</code> 预处理器将识别并展开宏 <code>PI</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> perimeter = <span class="hljs-number">2</span>*<span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><p>  通常，<u>宏的主体结束于 <code>#define</code>行的末尾</u>。如果需要，可以使用<strong>反斜杠</strong><code>\</code><strong>换行</strong>将定义继续到多行。然而，<u>当宏被展开时，它们都会出现在一行中</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUMBERS 1, \</span><br><span class="hljs-meta">                2, \</span><br><span class="hljs-meta">                3</span><br><br><span class="hljs-type">int</span> nums[] = &#123;NUMBERS&#125;;<br><br><span class="hljs-comment">// 预处理展开后：</span><br><br><span class="hljs-type">int</span> nums[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>这里官方文档说：因为预处理后宏会变成一行，那么报错信息提供的行号和我们实际所看到的行号就存在偏差。可能因为时间原因，这个问题已经不存在了：</p><p><img src="/img/in_posts/Macros/code1.png" alt="错误代码" />这段代码里，<code>return</code> 语句后没写分号。查看报错信息： <imgsrc="/img/in_posts/Macros/code1_err_info.png" alt="报错信息" />可以看到，报错信息里面行号是正常显示的，这个问题可以忽略。</p></blockquote><p>  在<code>C/C++</code>语言中定义宏时，宏体可以包含任何内容，只要这些内容能够分解成有效的<strong>预处理标记</strong>（<code>preprocessing tokens</code>）。这里的“预处理标记”指的是<u>预处理器能够识别的基本单位，比如关键字、标识符、字面量、运算符等</u>。&gt; 什么意思？如下： &gt; <strong>无限制的内容</strong> &gt;宏体中可以放入任何字符序列，<u>预处理器不会对宏体的内容做语法检查，它只负责将宏名替换为宏体的内容</u>；&gt; 正因如此，宏体中的代码片段甚至不必看起来是 <code>C/C++</code>的代码，但是编译结束可能会投来编译错误.😂</p><p>  <code>C/C++</code>预处理器<strong>按顺序扫描程序</strong>。宏定义在编写它们的地方生效，<u>也即是说在其定义之处之后的作用域内有效</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = N;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 3</span><br><span class="hljs-type">int</span> b = N;<br></code></pre></td></tr></table></figure><p>预处理之后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = N;<br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>这里就出错了，预处理器按顺序扫描到第一个语句时，<code>N</code>并没有被定义，而在其后方才被定义为宏，于是只有<code>b</code>的赋值语句中<code>N</code> 被正确展开成了 <code>3</code>。</p><p>  <code>C/C++</code>预处理器在处理宏时的展开过程。<u>当宏体中出现宏的调用（即宏名的使用）时，预处理器会将展开后的宏体中的宏继续展开</u>。这个过程是<strong>递归</strong>的，直到所有的宏都被替换为它们的值或者代码片段。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABLESIZE BUFFERSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 1024</span><br></code></pre></td></tr></table></figure><p>那么实际上，<code>TABLESIZE</code> 首先被展开成<code>BUFSIZE</code>，然后 <code>BUFSIZE</code> 又被展开为<code>4</code>，所以最终的效果是使用 <code>TABLESIZE</code>的地方都被展开成了 <code>4</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">TABLESIZE <br>    -&gt; BUFSIZE<br>    -&gt; <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>  注意，在定义 <code>TABLESIZE</code> 时没有定义<code>BUFSIZE</code>。<code>TABLESIZE</code>的<code>#define</code>完全使用指定的展开式，因为不会进行语法检查，并且不检查它是否也包含宏名称。只有当您使用<code>TABLESIZE</code>时，才会扫描其展开的结果以查找更多的宏名称，因为使用<code>TABLESIZE</code> 之处也处于 <code>BUFSIZE</code>作用域之内。这也说明了，宏指令的位置与最终展开的结果相关，预处理最终将会使用当前生效的宏进行展开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABLESIZE BUFSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> BUFSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 37</span><br></code></pre></td></tr></table></figure><p>这个示例中，<code>TABLESIZE</code> 最终被展开为了<code>37</code>。</p><p>  还有一种情况：如果宏体中包含自身的宏名称(直接或通过中间宏)，<u>则在检查更多宏时不再展开。这可以防止无限递归</u>。下面是一个例子来说明这种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO FOO</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>FOO</code> 宏被定义为它自己。当预处理器遇到<code>FOO</code> 时，它会尝试展开 <code>FOO</code>，但发现<code>FOO</code> 的定义就是它自己，所以预处理器不会再次展开<code>FOO</code>，避免了无限递归。</p><p>另一个更复杂的例子，涉及中间宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BAR FOO</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO BAR</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>FOO</code> 被定义为 <code>BAR</code>，而<code>BAR</code> 被定义为 <code>FOO</code>。如果预处理器尝试展开<code>FOO</code>，它会被替换为 <code>BAR</code>，然后 <code>BAR</code>又会尝试展开为 <code>FOO</code>，但此时预处理器已经知道 <code>FOO</code>会展开为 <code>BAR</code>，所以它不会再次展开<code>FOO</code>，避免了无限递归。</p><p>在这两种情况下，预处理器都会停止进一步展开宏，以防止无限递归的发生。这种自我引用的宏定义通常不是有意为之的，因为它们不会产生有用的结果，但它们确实展示了预处理器如何处理宏的递归展开，这部分将在后续<code>自引用宏章节</code> 介绍。</p><h3 id="类函数宏function-like-macros">类函数宏(Function-likeMacros)</h3><p>  实际上，还可以定义<strong>看起来像函数调用的宏</strong>。这些被称为<strong>类函数宏</strong>。要定义一个类似函数的宏，同样使用<code>#define</code>指令，但在<u>宏名称后紧接一对括号</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lang_init()  c_init()</span><br><br><span class="hljs-comment">// 预处理后</span><br><span class="hljs-built_in">lang_init</span>()<br>     -&gt; <span class="hljs-built_in">c_init</span>()<br></code></pre></td></tr></table></figure><p>当定义了一个类函数宏时，只有当这个宏的名字后面紧跟着一对括号时，它才会被展开。<u>如果宏的名字后面没有括号，那么它就不会被展开，而是保持原样</u>。这在存在同名的<strong>函数</strong>和<strong>类函数宏</strong>时，希望调用真实函数而不是宏时进行区分很有用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo() <span class="hljs-comment">/* optimized inline version */</span></span><br>...<br><span class="hljs-built_in">foo</span>();<br>funcptr = foo;<br></code></pre></td></tr></table></figure><p>这里对 <code>foo()</code> 的调用将使用<strong>宏</strong>，而函数指针<code>funcptr</code> 获取的是<strong>函数</strong><code>foo</code>的地址。但是这里如果将 <code>foo()</code> 进行展开将会出现语法错误……</p><p>  如果在宏定义中的宏名称和括号之间放置空格，则不是类函数宏，而是定义了一个类对象宏，其扩展恰好以一对括号开始：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lang_init ()  c_init()</span><br><br><span class="hljs-comment">// 预处理后</span><br><span class="hljs-built_in">lang_init</span>()<br>     -&gt; ()  <span class="hljs-built_in">c_init</span>()()<br></code></pre></td></tr></table></figure><p>需要注意。</p><!-- [官方文档](https://gcc.gnu.org/onlinedocs/cpp/Macros.html) -->]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Cpp</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试博客功能</title>
    <link href="/2024/11/16/test/"/>
    <url>/2024/11/16/test/</url>
    
    <content type="html"><![CDATA[<h1 id="线性代数二次型">线性代数——二次型</h1><h2id="一二次型的定义及其矩阵表达式">一、二次型的定义及其矩阵表达式</h2><p>  <span class="math inline">\(n\)</span> 元变量 <spanclass="math inline">\(x_1\)</span>，<spanclass="math inline">\(x_2\)</span>，...，<spanclass="math inline">\(x_n\)</span> 的二次齐次多项式</p><p><span class="math display">\[f(x_1, x_2, ..., x_n) =a_{11}x_1^2+2a_{12}x_1x_2+...+2a_{1n}x_1x_n\\\\+a_{22}x_2^2+2a_{23}x_2x_3+...+2a_{2n}x_2x_n\\\\+...+a_{nm}x_n^2\]</span></p><p>称为 <span class="math inline">\(n\)</span><strong>元二次型</strong>，简称<strong>二次型</strong>.</p><p>  这里只介绍系数 <span class="math inline">\(a_{ij} \in R(i \le j;i,j = 1, 2, ..., n)\)</span>的情况，称此二次型 <spanclass="math inline">\(f\)</span> 为<strong>实二次型</strong>.</p><p>  因为 <span class="math inline">\(x_ix_j = x_jx_i\)</span>，于是令<span class="math inline">\(a_{ij} = a_{ji}(i,j = 1, 2, ...,n)\)</span>，则 <span class="math inline">\(2a_{ij}x_ix_j =a_{ij}x_ix_j+a_{ji}x_jx_i\)</span>，于是令</p><p><span class="math display">\[\A = \begin{pmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\\\a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\end{pmatrix}\]</span></p><p><span class="math display">\[x = \begin{pmatrix}x_{1} \\\\x_{2} \\\\\vdots \\\\x_{n} \\\\\end{pmatrix}\]</span></p><p>则二次型可以表示为</p><p><span class="math display">\[f(x) = x^TAx\]</span></p><p>其中，<strong>实对称矩阵</strong><spanclass="math inline">\(A\)</span>称为<strong>二次型</strong><spanclass="math inline">\(f(x)\)</span><strong>的矩阵</strong>. 这里 <spanclass="math inline">\(A\)</span> 是一个对称矩阵，<spanclass="math inline">\(A_{ij} = (a_{ij}), a_{ij} =a_{ji}\)</span>，即满足 <span class="math inline">\(A^T = A\)</span>.实际上二次型可以有多种写法，如： <span class="math display">\[f(x) =x_1^2+x_2^2+4x_1x_2\]</span> 或 <span class="math display">\[f(x) =x_1^2+x_2^2+1x_1x_2+3x_2x_1\]</span></p><p>于是对应的矩阵 <span class="math inline">\(A\)</span> 分别为： <spanclass="math display">\[\A = \begin{pmatrix}1 &amp; 2  \\\\2 &amp; 1 \\\\\end{pmatrix}\]</span></p><p>和</p><p><span class="math display">\[\A = \begin{pmatrix}1 &amp; 1  \\\\3 &amp; 1 \\\\\end{pmatrix}\]</span></p><p>而这里作了规定，<strong>二次型的矩阵必须为对称矩阵</strong>，那么如此代表二次型的矩阵就是<strong>唯一</strong>的了.</p><h2id="二合同变换二次型的合同标准型规范型">二、合同变换，二次型的合同标准型、规范型</h2><h3 id="线性变换的定义">1.线性变换的定义</h3><p>  对于 <span class="math inline">\(n\)</span>元二次型 <spanclass="math inline">\(f(x_1, x_2, ..., x_n)\)</span>，若令</p><p><span class="math display">\[ \left\{\begin{aligned}x_1 &amp;= c_{11}y_1 + c_{12}y_2 + \cdots + c_{1n}y_n \\x_2 &amp;= c_{21}y_1 + c_{22}y_2 + \cdots + c_{2n}y_n \\&amp;\vdots \\x_n &amp;= c_{n1}y_1 + c_{n2}y_2 + \cdots + c_{nn}y_n\end{aligned}\right.\]</span></p><p>记 <span class="math display">\[x = \begin{pmatrix}x_{1} \\\\x_{2} \\\\\vdots \\\\x_{n} \\\\\end{pmatrix}\]</span></p><p><span class="math display">\[\C = \begin{pmatrix}c_{11} &amp; c_{12} &amp; \cdots &amp; c_{1n} \\\\c_{21} &amp; c_{22} &amp; \cdots &amp; c_{2n} \\\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\c_{n1} &amp; c_{n2} &amp; \cdots &amp; c_{nn}\end{pmatrix}\]</span></p><p><span class="math display">\[y = \begin{pmatrix}y_{1} \\\\y_{2} \\\\\vdots \\\\y_{n} \\\\\end{pmatrix}\]</span></p><p>则，上式可以写为：</p><p><span class="math display">\[x = Cy\]</span>上述变换称为<strong>线性变换</strong>，若线性变换的系数矩阵<spanclass="math inline">\(C\)</span>可逆，即 <span class="math inline">\(|C|\ne 0\)</span>，则称为<strong>可逆线性变换</strong>. 现给出： <spanclass="math display">\[f(x) = x^TAx\]</span> 令 <spanclass="math inline">\(x = Cy\)</span>，则 <spanclass="math display">\[f(x) = (Cy)^TA(Cy) = y^T(C^TAC)y\]</span> 记<span class="math inline">\(B = C^TAC\)</span>，则 <spanclass="math display">\[f(x) = y^TBy = g(y)\]</span>显然，这又是一个新的二次型：即二次型 <spanclass="math inline">\(f(x)=x^TAx\)</span>通过线性变换 <spanclass="math inline">\(x=Cy\)</span> 得到了一个新的二次型 <spanclass="math inline">\(g(y) = y^TBy\)</span></p><p><img src="/img/in_posts/blog_start/changli.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
      <tag>latex</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇个人博客</title>
    <link href="/2024/11/15/first-blog/"/>
    <url>/2024/11/15/first-blog/</url>
    
    <content type="html"><![CDATA[<h3 id="开始的地方">开始的地方</h3><p>  Hi everyone. I'm HiJackiee and this is my first personal blog!</p><figure><img src="/img/in_posts/blog_start/changli.png"alt="和光同尘，与时舒卷." /><figcaption aria-hidden="true">和光同尘，与时舒卷.</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>introduction</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
