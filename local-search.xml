<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>YOLO v1 论文分享</title>
    <link href="/2025/01/01/YOLO/You_Only_Look_Once/"/>
    <url>/2025/01/01/YOLO/You_Only_Look_Once/</url>
    
    <content type="html"><![CDATA[<h2 id="you-only-look-once-unified-real-time-object-detection"><spanclass="math inline">\(You\ Only\ Look\ Once:\ Unified,\ Real-Time\Object\ Detection\)</span></h2><blockquote><p><a href="https://arxiv.org/abs/1506.02640">论文链接</a> <ahref="https://pjreddie.com/darknet/yolo/">项目地址</a></p></blockquote><h3 id="摘要-abstract">摘要 Abstract</h3><ul><li><strong>YOLO介绍</strong><br>提出了一种名为 <code>YOLO</code>的新方法，用于目标检测（<code>object detection</code>）。这种方法将目标检测视为一个<strong>回归问题</strong>，直接从整张图像预测边界框和类别概率，而不是重新利用分类器进行检测（之前工作的主要方向）。&gt;<strong>边界框</strong>（<code>Bounding Box</code>）是目标检测中用于定位图像内目标位置的矩形区域，用于确定目标的确切位置、进行分类以及评估预测的准确性，常以不同颜色或样式的矩形框在图像上显示，便于可视化分析。在<code>YOLO</code>算法中，每个网格单元预测多个边界框及其置信度和条件类别概率，实现快速目标检测。</li></ul><blockquote><p><strong>类别概率</strong>（<code>class probabilities</code>）是指在机器学习和模式识别任务中，模型对于给定输入样本属于某个特定类别的置信度或概率估计。在目标检测和图像识别等任务中，类别概率尤为重要，因为它们不仅需要识别出图像中的对象，还需要确定这些对象属于哪个类别。<br><br>在<code>YOLO</code>算法中，类别概率是指每个网格单元预测的边界框内包含某个类别目标的概率。这些概率值是<strong>条件概率</strong>，即在网格单元内确实存在目标的条件下（所以与边界框的置信度是由关联的），边界框包含特定类别目标的概率。通过这种方式，<code>YOLO</code>能够同时预测目标的位置和类别，实现快速且准确的目标检测。</p></blockquote><ul><li><strong>速度与性能</strong><br><code>YOLO</code>的统一架构非常快速，基础模型能够以每秒<code>45</code>帧的速度实时处理图像。还有一个更小的版本，<code>Fast YOLO</code>，能够达到惊人的每秒<code>155</code>帧，同时在平均精度均值（<code>mAP</code>）上是其他实时检测器的两倍。</li><li><strong>准确性与泛化</strong><br>与最先进的检测系统相比，<code>YOLO</code>在目标定位上可能会犯更多错误，但不太可能在背景上预测出错误的正例。此外，<code>YOLO</code>学习到的目标表示具有很好的泛化能力，当从自然图像泛化到其他领域（如艺术品）时，其表现优于其他检测方法，包括<code>DPM</code>和<code>R-CNN</code>。</li></ul><h3 id="介绍-introduction">介绍 Introduction</h3><p>  论文引言部分，作者总结了之前目标检测算法使用的主要方法：</p><h4 id="之前的目标检测算法主要方法">之前的目标检测算法主要方法</h4><ol type="1"><li><p><strong>分类器再利用</strong><br>以往的系统通常将分类器用于检测任务，通过在测试图像的不同位置和尺度上评估分类器来检测对象。</p></li><li><p><strong>滑动窗口方法</strong><br>如可变形部件模型（<code>Deformable Parts Models</code>,<code>DPM</code>），它们使用滑动窗口方法，在图像的固定间隔位置上运行分类器。</p></li><li><p><strong>区域提议方法</strong><br>如<code>R-CNN</code>系列方法，首先生成潜在的边界框，然后在这些提议的框上运行分类器，之后使用<strong>后处理</strong>来优化边界框和消除重复检测。</p></li></ol><h4 id="yolo与之前方法的对比">YOLO与之前方法的对比</h4><ol type="1"><li><p><strong>统一的框架</strong><br><code>YOLO</code>将目标检测框架为一个单一的回归问题，直接从图像像素预测边界框坐标和类别概率，而不是将分类器用于检测。</p></li><li><p><strong>端到端优化</strong><br><code>YOLO</code>作为一个单一网络，可以端到端直接优化检测性能，而传统方法需要分别训练和优化多个组件。</p></li><li><p><strong>速度</strong><br><code>YOLO</code>的统一架构非常快速，能够实现实时目标检测，而传统方法由于复杂的处理流程，速度较慢。</p></li><li><p><strong>全局推理</strong><br><code>YOLO</code>在训练和测试时能够看到整个图像，隐式编码类别和外观的上下文信息，而传统方法如滑动窗口和区域提议方法只能看到局部信息。</p></li><li><p><strong>泛化能力</strong><br><code>YOLO</code>学习到的目标表示具有很好的泛化能力，能够在不同领域中表现优于其他检测方法。</p></li></ol><h3 id="统一检测-unified-detection">统一检测 Unified Detection</h3><p>  <code>YOLO</code>通过将目标检测的各个环节整合进一个神经网络，实现了利用整张图像的特征来同时预测所有类别的边界框，并进行全局推理，这样的设计使得<code>YOLO</code>不仅能够端到端训练，还能在保持高平均精度的同时达到实时的检测速度。</p><p>  <code>YOLO</code> 将输入的图像划分为 <span class="math inline">\(S\times S\)</span>网格。<strong>如果物体的中心落入一个网格单元，则该网格单元负责检测该物体</strong>；<br></p><p>  每个网格单元预测<code>B</code>（用<code>B</code>表示是出于<code>Boxes</code>）个边界框以及这些框的置信度分数。这些<strong>置信度分数</strong>反映了模型对于边界框内包含物体的置信度，同时也反映了模型对其边界框准确性的评估。<br>形式上，<code>YOLO</code>将置信度定义为</p><p><span class="math display">\[Confidence =Pr(Object)*IOU_{pred}^{truth}\]</span> &gt; <spanclass="math inline">\(Pr(Object)\)</span>：模型预测某个边界框包含至少一个对象的概率。<spanclass="math inline">\(Pr\)</span> 代表概率。</p><p>  如果网格单元中不存在物体，则置信度得分应该为<code>0</code>。否则，置信度得分希望等于边界框与真实值之间的<strong>交并比</strong>（<code>IOU</code>）。<br>&gt;交并比（<code>Intersection Over Union</code>，<code>IOU</code>）是目标检测和图像分割任务中常用的评估指标，用于衡量两个边界框（或区域）之间的重叠程度。<code>IOU</code>计算的是两个边界框交集面积与并集面积的比值。<spanclass="math display">\[IOU^{A}_{B} = \frac{Area(A \cap B)}{Area(A) +Area(B) - Area(A \cap B)}\]</span><br></p><p>  每个边界框包含<code>5</code>个预测值：<code>x</code>，<code>y</code>，<code>w</code>，<code>h</code>以及<code>置信度</code>。<code>(x, y)</code>坐标表示边界框的中心<strong>相对于网格单元边界的相对位置</strong>，其数值是归一化的结果。比如：</p><p><img src="/img/in_posts/YOLO/YOLO_v1/image-1.png" /></p><p>  <strong>宽度</strong><code>w</code>和<strong>高度</strong><code>h</code>是<u>相对于整个图像的预测值</u>。也就是说，<strong>一个网格单元预测的边界框的中心必须落在该网格单元内，但此边界框的大小范围可以超出此网格单元，其范围大小是相对于整张图像而言的</strong>，其数值也是归一化的结果。</p><p><img src="/img/in_posts/YOLO/YOLO_v1/image-2.png" /></p><p>  <strong>置信度</strong>表示边界框与任何真实值框之间的<code>IOU</code>（交并比）。<br></p><p>  每个网格单元还预测<code>C</code>个<strong>条件类别概率</strong>，<spanclass="math inline">\(Pr(Class_i | Object)\)</span>。这些概率是基于网格单元包含一个物体的条件，即条件概率。<u>无论网格单元中的边界框数量<code>B</code> 有多少，都只预测一组类别概率</u>。<br></p><p>  测试时，将条件类别概率与各个边界框的置信度预测相乘，</p><p><span class="math display">\[Pr(Class_i | Object) * Pr(Object) *IOU_{pred}^{truth} \\\\ = Pr(Class_i) * IOU_{pred}^{truth}······（1）\]</span></p><p>可得每个框的<strong>针对类别的置信度分数</strong>。这些分数既编码了该类别出现在框中的概率，也编码了边界框与对象的拟合程度。&gt;这里说明，模型不仅给出了每个边界框内包含对象的置信度，而且给出了这个边界框内对象属于特定类别的置信度</p><p><img src="/img/in_posts/YOLO/YOLO_v1/image.png" /></p><p>  <code>YOLO</code> 将检测建模为一个回归问题。它将图像划分为 <spanclass="math inline">\(S \times S\)</span> 的网格，并为每个网格单元预测<span class="math inline">\(B\)</span> 个边界框、这些边界框的置信度以及<span class="math inline">\(C\)</span> 个类别概率。这些预测被编码为一个<span class="math inline">\(S \times S \times (B * 5 + C)\)</span>的<strong>张量</strong>。</p><p><br></p><h4 id="网络设计-network-design">网络设计 Network Design</h4><p>  <code>YOLO</code>模型被实现为<strong>卷积神经网络</strong>，网络的初始卷积层从图像中提取特征，而在<strong>全连接层</strong>预测输出概率和坐标。受到用于图像分类的<code>GoogLeNet</code>模型的启发，<code>YOLO</code>网络结构包含<code>24</code>个卷积层，随后是<code>2</code>个全连接层。与<code>GoogLeNet</code> 模型使用的 <code>inception</code>模块不同的是，<code>YOLO</code>在 <code>3x3</code>的卷积层后使用<code>1x1</code>的降维层。直接看结构图：</p><figure><img src="/img/in_posts/YOLO/YOLO_v1/image-3.png" alt="模型结构图" /><figcaption aria-hidden="true">模型结构图</figcaption></figure><p>输入图像大小为 <code>448x448</code>，经过 <code>24</code>个卷积层和若干池化层后输出为<code>7x7x1024</code>张量（倒数第三个立方体），最后再经过两层全连接层，得到网络的最终输出，即预测的<code>7x7x30</code>张量。根据前面的内容，预测的结果是 <spanclass="math inline">\(S \times S \times (B * 5 + C)\)</span>，这里的<code>7x7x30</code> 含义是:</p><ul><li><code>448x448</code>的图像被划分为<code>7x7</code> 的网络；</li><li>论文中，<code>B</code>取值可以调整，这里取<code>B = 2</code>，即每个网格单元预测 <code>2</code>个边界框。而类别概率数量 <code>C</code> 取值为<code>20</code>。于是最终得到 <code>(2 * 5 + 20) = 30</code>。</li></ul><p><img src="/img/in_posts/YOLO/YOLO_v1/image-4.png" /></p><p>对于整个结构，由多个卷积层和池化层组成，以提取图像的特征。初始的卷积层使用<code>7x7</code>的卷积核，步长为<code>2</code>，这会将输入图像的特征图尺寸减半，同时增加深度。随后，网络中<strong>交替使用</strong><code>3x3</code>卷积层和<code>1x1</code>卷积层，其中<code>3x3</code>卷积层用于捕捉局部特征，而<code>1x1</code>卷积层则用于<u>降低特征图的通道数，减少参数数量，并在特征融合中引入非线性</u>。此外，网络中还包含最大池化层，用于降低特征图的空间维度，增加感受野，并提供平移不变性。最终，经过一系列卷积和池化操作后，特征图被展平并通过全连接层，输出最终的预测结果，包括边界框的位置、尺寸和类别概率。在最后一个卷积层，它输出一个形状为<code>(7, 7, 1024)</code>的张量，然后张量展开。使用<code>2</code>个全连接层作为一种线性回归的形式，它输出<code>1470</code>个参数，然后<code>reshape</code>为<code>(7, 7, 30)</code>。</p><blockquote><p>除了<code>YOLO</code>外，作者还训练了一个快速版本的<code>YOLO</code>，旨在突破快速目标检测的界限。<code>Fast YOLO</code>使用了一个具有较少卷积层（<code>9</code>层而不是<code>24</code>层）和较少滤波器的神经网络。除了网络的大小外，<code>YOLO</code>和<code>Fast YOLO</code>的所有训练和测试参数都相同。</p></blockquote><h3 id="训练-training">训练 Training</h3><p>  <code>YOLO</code>模型首先在<code>ImageNet</code>的<code>1000</code>类分类数据集上进行预训练，使用前<code>20</code>个卷积层以及平均池化层和全连接层，达到<code>88%</code>的<code>top-5</code>准确率。</p><p>  为了进行目标检测，模型增加了<code>四个卷积层</code>和<code>两个全连接层</code>，并将输入分辨率从<code>224x224</code>提升至<code>448x448</code>以捕捉更精细的视觉信息。</p><p>  模型的输出层预测归一化的边界框坐标和类别概率，其中边界框的宽高和图像宽高成比例，坐标则是相对于网格单元的偏移量。和前面的描述保持一致。</p><p>  除了对网络结构的最后一层使用线性激活函数外，其他所有层使用了下面的<code>Leaky ReLU</code> 函数：</p><p><span class="math display">\[\phi(x) = \begin{cases} x,\ if\ x &gt;\0 \\\\  0.1x,\ otherwise \end{cases} ······（2） \]</span></p><p>  论文中优化了模型输出中的平方和误差:</p><h4 id="平方和误差的局限性">平方和误差的局限性</h4><ol type="1"><li>将定位误差和分类误差同等对待<br>在目标检测中，<strong>定位误差</strong>直接影响到预测框与真实物体的交并比<code>IOU</code>。而<strong>分类误差</strong>对检测性能的影响相对较小，分类误差主要影响的是识别物体类别的准确性，但在有些情况下，即使分类错误或导致检测结果不正确，只要检测的位置和大小足够正确，检测的结果也可以被接受；</li><li>将大框和小框的误差同等对待<br>世界上，小框对误差更加敏感，因为小框的交并比（<code>IOU</code>）对定位精度要求更高。</li></ol><h4 id="优化措施">优化措施</h4><ol type="1"><li>对于定位误差和分类误差，<code>YOLO</code>在损失函数中引入了两个参数：<spanclass="math inline">\(\lambda_{coord}\)</span> 和 <spanclass="math inline">\(\lambda_{noobj}\)</span>。<ul><li><span class="math inline">\(\lambda_{coord}\)</span>用于<u>增加边界框坐标预测的权重</u>；</li><li><span class="math inline">\(\lambda_{noobj}\)</span>用于<u>减少不包含物体的网格单元的置信度预测的权重</u>。</li><li>论文中设置 <span class="math inline">\(\lambda_{coord} = 5\)</span>和 <span class="math inline">\(\lambda_{noobj} =0.5\)</span>，使模型更加关注边界框的精准定位，并减少了对不包含物体的网格单元的置信度预测惩罚。</li></ul></li><li>对于大框和小框对误差的敏感性不同，<code>YOLO</code>在损失函数中使用的是高度和宽带的平方根，而不是直接使用高度和宽度。比如，对于宽度<code>w</code>： <imgsrc="/img/in_posts/YOLO/YOLO_v1/image-5.png" /><br>可以看到，对于同等误差 <span class="math inline">\(\Deltaw\)</span>，小框较大框更加敏感，很好地契合了优化目的。</li></ol><p>  于是，通过前面的优化，<code>YOLO</code>使用了如下的，多部分和的损失函数：</p><p><span class="math display">\[\begin{aligned} \lambda_{coord}\sum_{i=1}^{S^2} \sum_{j=1}^{B}\ \mathbf{1}_{ij}^{obj}[(x_i-\hat{x_i})^2+ (y_i - \hat{y_i})^2]+ \\\\ \lambda_{coord} \sum_{i=1}^{S^2}\sum_{j=1}^{B}\ \mathbf{1}_{ij}^{obj}[(\sqrt{w_i}-\sqrt{\hat{w_i}})^2 +(\sqrt{h_i}-\sqrt{\hat{h_i}}\ )^2] \\\\ + \sum_{i=1}^{S^2}\sum_{j=1}^{B}\ \mathbf{1}_{ij}^{obj} (C_i - \hat{C_i})^2 \\\\ +\lambda_{noobj} \sum_{i=1}^{S^2} \sum_{j=1}^{B} \mathbf{1}_{ij}^{noobj}(C_i - \hat{C_i})^2 \\\\ + \sum_{i=1}^{S^2} \sum_{c \in classes} (p_i(c)- \hat{p_i}(c))^2 \\\\ ······（3）\end{aligned}\]</span></p><blockquote><p>论文中这里貌似出现了笔误，论文中的损失函数中求和是从 <code>i=0</code>到 <code>S^2</code>，即 <span class="math inline">\(\sum_{i =0}^{S^2}\)</span>，实际上应该为<span class="math inline">\(\sum_{i =1}^{S^2}\)</span> 或者 <span class="math inline">\(\sum_{i = 0}^{S^2 -1}\)</span>。</p></blockquote><p>损失函数中的 <span class="math inline">\(\mathbf{1}\)</span>符号是一个指示函数，其中： - <spanclass="math inline">\(\mathbf{1}_{i}^{obj}\)</span> 表示第<code>i</code> 个网格单元是否包含物体，是则 <spanclass="math inline">\(\mathbf{1}_{i}^{obj} = 1\)</span>，否则 <spanclass="math inline">\(\mathbf{1}_{i}^{obj} = 0\)</span>，即：</p><p><span class="math display">\[\mathbf{1}_{i}^{obj} = \begin{cases} 1,\网格单元包含物体 \\\\ 0,\ 网格单元不含物体\end{cases}\]</span></p><p><span class="math inline">\(\mathbf{1}_{i}^{noobj}\)</span>恰与之相反：</p><p><span class="math display">\[\mathbf{1}_{i}^{noobj} = \begin{cases}1,\ 网格单元不含物体 \\\\ 0,\ 网格单元包含物体\end{cases}\]</span></p><ul><li><p><span class="math inline">\(\mathbf{1}_{ij}^{obj}\)</span> 表示第<code>i</code> 个网格单元的第 <code>j</code>个边界框预测器是否负责预测一个物体（一个网格单元会预测 <code>B</code>个边界框），是则 <span class="math inline">\(\mathbf{1}_{ij}^{obj} =1\)</span>，否则 <span class="math inline">\(\mathbf{1}_{ij}^{obj} =0\)</span>，即：</p><p><span class="math display">\[\mathbf{1}_{ij}^{obj} = \begin{cases}1,\ 第 i 个网格单元的第 j 个边界框预测器是否负责预测一个物体 \\\\ 0,\否则\end{cases}\]</span></p></li></ul><p>  实际上，上述损失函数可以分为以下几个部分：</p><ol type="1"><li><p><strong>位置误差</strong></p><p><span class="math display">\[\lambda_{coord} \sum_{i=1}^{S^2}\sum_{j=1}^{B}\ \mathbf{1}_{ij}^{obj}[(x_i-\hat{x_i})^2 + (y_i -\hat{y_i})^2]+ \\\\ \lambda_{coord} \sum_{i=1}^{S^2} \sum_{j=1}^{B}\\mathbf{1}_{ij}^{obj}[(\sqrt{w_i}-\sqrt{\hat{w_i}})^2 +(\sqrt{h_i}-\sqrt{\hat{h_i}}\ )^2] \]</span></p></li><li><p><strong>置信度误差（含物体时）</strong></p><p><span class="math display">\[\sum_{i=1}^{S^2} \sum_{j=1}^{B}\\mathbf{1}_{ij}^{obj} (C_i - \hat{C_i})^2 \]</span></p></li><li><p><strong>置信度误差（不含物体时）</strong></p><p><span class="math display">\[\lambda_{noobj} \sum_{i=1}^{S^2}\sum_{j=1}^{B} \mathbf{1}_{ij}^{noobj} (C_i -\hat{C_i})^2\]</span></p></li><li><p><strong>分类误差</strong></p><p><span class="math display">\[\sum_{i=1}^{S^2} \sum_{c \in classes}(p_i ( c ) - \hat{p_i} ( c ) )^2\]</span> 其中，<spanclass="math inline">\(p_i ( c )\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个网格单元中的物体属于类别 <spanclass="math inline">\(c\)</span> 的真实概率，而 <spanclass="math inline">\(\hat{p_i} ( c )\)</span>表示模型预测的类别概率。事实上，损失函数中的 “含帽”的变量是模型预测的相关值。</p></li></ol><p>  由损失函数不难看出，由于分类误差中含有指示函数 <spanclass="math inline">\(\mathbf{1}_{i}^{obj}\)</span>，所以损失函数只会在该网格单元中存在物体时才对分类误差进行惩罚。</p><p>  此外，由于位置误差中指示函数 <spanclass="math inline">\(\mathbf{1}_{ij}^{obj}\)</span>的存在，损失函数只会某个某个边界框预测器对真实值框 “负责”时会惩罚边界框的位置误差。</p><h3 id="yolo-的局限性">YOLO 的局限性</h3><p>YOLO的局限性主要包括以下几点：</p><ol type="1"><li><p><strong>空间约束</strong>：<code>YOLO</code>对边界框预测施加了严格的空间限制，每个网格单元只能预测两个框，并且每个框只能有一个类别。这种设计限制了模型对邻近物体的检测能力，尤其是在物体密集或重叠的情况下，<code>YOLO</code>可能会漏检一些物体；</p></li><li><p><strong>小物体检测困难</strong>：由于每个网格单元的预测能力有限，<code>YOLO</code>在检测成群出现的小物体时表现不佳，例如鸟群或昆虫群等。这些小物体可能因为尺寸小且数量多而难以被准确识别和定位；</p></li><li><p><strong>特征粗糙</strong>：<code>YOLO</code>的网络结构中包含多个下采样层，导致其在预测边界框时使用的特征较为粗糙。这使得模型在处理需要精细特征的物体时（如具有复杂形状或纹理的物体）可能不够准确；</p></li><li><p><strong>损失函数的局限</strong>：<code>YOLO</code>的损失函数在处理小框和大框的误差时没有区别对待，即对小框中的小误差和大框中的小误差赋予相同的权重。然而，在实际检测中，小框中的小误差对交并比（<code>IoU</code>）的影响较大，而大框中的小误差影响较小。这可能导致模型在优化过程中对小物体的定位不够准确；</p></li><li><p><strong>类别泛化能力有限</strong>：虽然<code>YOLO</code>在一定程度上能够泛化到新的领域或数据分布，但其在处理与训练数据分布差异较大的场景时，可能会出现性能下降的情况。这是因为模型的特征学习和类别识别能力在很大程度上依赖于训练数据的多样性和代表性。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>YOLO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PaperShare</tag>
      
      <tag>YOLO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程之层次锁</title>
    <link href="/2024/12/26/Concurrency/c++%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B1%82%E6%AC%A1%E9%94%81/"/>
    <url>/2024/12/26/Concurrency/c++%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B1%82%E6%AC%A1%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="层次锁hierarchical-lock">层次锁⌊hierarchical lock⌉</h2><p>  在<code>C++</code>多线程编程中，避免死锁是一大要务。简单回顾一下死锁的概念：</p><h3 id="死锁">死锁</h3><p>  死锁（<code>Deadlock</code>）多线程执行过程中，每个线程都持有一些资源，同时又尝试获取其他线程所持有的资源，导致所有线程都无法继续执行的一种状态。简单理解，就是多个线程相互等待对方释放资源，但没有任何线程能够继续向前推进。</p><p>  死锁通常涉及四个基本条件：</p><ol type="1"><li><p><strong>互斥</strong><br>指资源在某一时刻只能被一个线程使用，如多线程编程中常见的互斥元<code>mutex</code>；</p></li><li><p><strong>占有和等待</strong><br>指一个线程至少占有一个资源，同时又等待获取其他线程占有的资源；</p></li><li><p><strong>不可抢占</strong><br>指资源只能由占有它的线程资源释放，而不能强行剥夺；</p></li><li><p><strong>循环等待</strong><br>指存在一个线程的集合，其中每个线程都在等待下一个线程所占有的资源，形成一个等待的循环。</p></li></ol><h3 id="避免死锁">避免死锁</h3><p>  避免死锁的方法有很多，基本思路就是破坏死锁发生的四个基本条件：</p><ol type="1"><li><p><strong>破坏互斥条件</strong><br>即允许资源同时被多个线程访问，但这通常并不适合需要互斥访问的资源；</p></li><li><p><strong>破坏占有与等待条件</strong><br>要求线程在请求新资源之前释放所有已占有的资源；</p></li><li><p><strong>破坏不可抢占条件</strong><br>允许资源被抢占，在实践中这很难实现；</p></li><li><p><strong>破坏循环等待条件</strong><br>通过给所有资源（如互斥元）编号一个顺序，并要求线程按照这个顺序请求资源；</p></li></ol><p>  我们这里讨论破坏循环等待条件的情况，即为所有资源编号一个顺序，使得所有线程只能按照固定的顺序请求资源。下面的“资源”统一以互斥元（<code>mutex</code>）为例。</p><h4 id="以固定顺序获取锁">以固定顺序获取锁</h4><p>  相当直观的一个事实：当死锁发生时，必须存在一个线程之间的等待循环，每个线程都在等待下一个线程释放资源。如果存在两个或者更多的互斥元，<code>C++17</code>引入了 <code>std::lock</code>的方法来<strong>原子性</strong>地锁定多个互斥元，也即是说<u>要么同时锁定多个互斥元，要么阻塞当前线程直到所有的互斥元都可用</u>。这是可以考虑地一种方法，但是当不能使用<code>std::lock</code>的单个操作取得多个锁时，次优的做法就是在每个线程中以相同的顺序获取互斥元，也就是破坏循环等待条件。</p><p>  很好理解的是，这里的<code>顺序</code>是一种全局的顺序，而非相对的。什么意思，比如，一个函数的参数列表中传入两个互斥元，我们以一种相对的顺序：先锁第一个参数，再锁第二个参数，此时就是一种相对的而非全局的顺序。很显然，这样的相对锁定顺序同样会引起死锁的发生——当线程<code>A</code> 和线程 <code>B</code>的参数顺序恰好相反时，这就是一个典型的死锁。</p><p>  如何实现一种全局的顺序呢？下面介绍的<strong>层次锁</strong>将是一个不错的方法。</p><h3 id="使用层次锁">使用层次锁</h3><p>  你可以称之为<code>层次锁⌊hierarchical lock⌉</code>、<code>层次互斥元⌊hierarchical_mutex⌉</code>（<code>hierarchical adj 分等级的</code>）等等，一切都是接受的，这并非关键。<strong>层次锁</strong>并未在<code>C++</code>标准中得到实现，而是一种用户自定义的互斥锁，这很有用，兴许不久的将来会看到它会进入到<code>C++</code>标准中。层次锁实际上是定义了互斥元的锁定顺序的特例，并在实际运行中检查是否遵循这种<code>顺序</code>。</p><p>  <code>hierarchical_mutex</code>的工作原理基于一个简单的规则：在同一线程中，只能按照层次值递减的顺序锁定多个<code>hierarchical_mutex</code>。这实际上就体现了锁定的固定顺序：即从<u>高到低的顺序</u>。如果尝试违反这一规则的顺序锁定互斥元，<code>hierarchical_mutex</code>会抛出异常，表明层次被违反。这里需要注意的是：如果锁在层次中处于相同级别，则不能同时持有它们。</p><blockquote><p>那么实现细节？</p></blockquote><p>  一个自定义的 <code>hierarchical_mutex</code>类通常包含以下几个部分：</p><ol type="1"><li>一个内部的 <code>std::mutex</code> 用于实际的互斥；</li><li>一个 <code>hierarchical_value</code> 用于存储该互斥锁的层次值；</li><li>一个 <code>previous_hierarchy_value</code>用于存储当前线程的前一个层次值；</li><li>一个 <code>this_thread_hierarchy_value</code>的静态局部变量，用于跟踪当前线程的层次值。</li></ol><p>  当然，为了支持 <code>std::lock_guard</code> 的 <code>RAII</code>惯用语法，<code>hierarchical_mutex</code> 类提供了<code>lock</code>、<code>unlock</code> 和 <code>try_lock</code>等成员函数，以支持互斥锁的基本操作，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(hierarchical_mutex(<span class="hljs-number">5000</span> <span class="hljs-comment">/*层次值*/</span>))</span></span><br></code></pre></td></tr></table></figure><blockquote><p><code>try_lock()</code>成员函数用于尝试锁定一个互斥元，若互斥元的锁已经为另一个线程所持有，则返回<code>false</code></p></blockquote><p>下面是 <code>hierarchical_mutex</code> 的简单实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">hierarchical_mutex</span>&#123;<br>    std::mutex internal_mutex;  <span class="hljs-comment">// 用于实际的互斥</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">const</span> hierarchy_value;    <span class="hljs-comment">// 存储该互斥锁的层次值</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> previous_hierarchy_value;   <span class="hljs-comment">// 存储当前线程的前一个层次值</span><br>                                              <span class="hljs-comment">// 互斥元解锁时恢复层次值</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">thread_local</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> this_thread_hierarchy_value;  <br>            <span class="hljs-comment">// thread_local 用于声明一个局部于线程的静态变量，这意味着每个线程都会拥有该</span><br>            <span class="hljs-comment">// 变量的独立副本。这类变量称为线程局部存储（Thread-Local Storge, TLS）</span><br>            <span class="hljs-comment">// 生命周期是始于线程创建，终于线程结束</span><br><br>            <span class="hljs-comment">// this_thread_hierarchy_value 用于跟踪当前线程的层次值</span><br><br>    <span class="hljs-comment">// 规则检查</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_for_hierarchy_violation</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 锁定顺序应该是由高到低，当前线程只能锁定层次值低于自身的互斥元</span><br>        <span class="hljs-keyword">if</span> (this_thread_hierarchy_value &lt;= hierarchy_value)&#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;mutex hierarchy violated&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新层次值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_hierarchy_value</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 保存当前线程层次值到 previous_hierarchy_value</span><br>        previous_hierarchy_value = this_thread_hierarchy_value;<br><br>        <span class="hljs-comment">// 锁定一个互斥元后将线程的层次值更新为互斥元对应的层次值</span><br>        this_thread_hierarchy_value = hierarchy_value;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数，接受一个 unsigned long 类型的层次值</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">hierarchical_mutex</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> value)</span>: hierarchy_value(value),</span><br><span class="hljs-function">            previous_hierarchy_value(<span class="hljs-number">0</span>) &#123;</span>&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">check_for_hierarchy_violation</span>();<br>        internal_mutex.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-built_in">update_hierarchy_value</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 恢复当前线程的层次值为 previous_hierarchy_value</span><br>        this_thread_hierarchy_value = previous_hierarchy_value;<br>        internal_mutex.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">check_for_hierarchy_violation</span>();<br>        <span class="hljs-keyword">if</span> (!internal_mutex.<span class="hljs-built_in">try_lock</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-built_in">update_hierarchy_value</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// this_thread_hierarchy_value 设置为 ULONG_MAX，即初始化为最大值，目的就是使其初始时可</span><br><span class="hljs-comment">// 以锁定任何层次值的互斥元，选取哪一层次的锁作为开始总是自由的</span><br><span class="hljs-function"><span class="hljs-keyword">thread_local</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> </span><br><span class="hljs-function">    <span class="hljs-title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="hljs-params">(ULONG_MAX)</span></span>;<br></code></pre></td></tr></table></figure><p>  下面以一个实际例子来讲解 <code>hierarchical_mutex</code>的作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">hierarchical_mutex <span class="hljs-title">high_level_mutex</span><span class="hljs-params">(<span class="hljs-number">10000</span>)</span></span>; <span class="hljs-comment">// 定义一个高层次值的层次互斥元</span><br><span class="hljs-function">hierarchical_mutex <span class="hljs-title">low_level_mutex</span><span class="hljs-params">(<span class="hljs-number">5000</span>)</span></span>;   <span class="hljs-comment">// 定义一个低层次值的层次互斥元</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">do_low_level_stuff</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">low_level_func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(low_level_mutex)</span></span>; <span class="hljs-comment">// RAII 语法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">do_low_level_stuff</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">high_level_stuff</span><span class="hljs-params">(<span class="hljs-type">int</span> some_param)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">high_level_func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(high_level_mutex)</span></span>;<br>    <span class="hljs-built_in">high_level_stuff</span>(<span class="hljs-built_in">low_level_func</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_a</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">high_level_func</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是整个代码函数依赖图：</p><pre><code class=" mermaid">graph TD    threadA[&quot;thread_a()&quot;]    highLevelFunc[&quot;high_level_func()&quot;]    lowLevelFunc[&quot;low_level_func()&quot;]    doLowLevelStuff[&quot;do_low_level_stuff()&quot;]    highLevelStuff[&quot;high_level_stuff()&quot;]    threadA --&gt; highLevelFunc    highLevelFunc --&gt; lowLevelFunc    highLevelFunc --&gt; highLevelStuff    lowLevelFunc --&gt; doLowLevelStuff</code></pre><p>  假设线程<code>a</code> 执行 <code>thread_a</code>函数，初始时，线程 <code>a</code>的<code>this_thread_hierarchy_value</code> 为<code>ULONG_MAX</code>，即最大值。之后，<code>thread_a()</code> 调用<code>high_level_func()</code>，并锁定了<code>high_level_mutex</code>（具有层次值为<code>10000</code>），使得线程 <code>a</code> 的<code>this_thread_hierarchy_value</code> 值更新为当前层次互斥元的层次值<code>10000</code>。然后在 <code>high_level_func()</code> 中调用了<code>low_level_func()</code>，并锁定了<code>low_level_mutex</code>（具有层次值为 <code>5000</code>），此时线程<code>a</code> 的 <code>this_thread_hierarchy_value</code>值更新为当前层次互斥元的层次值 <code>5000</code>。所有，线程<code>a</code> 对层次互斥元的锁定符合由高到低的顺序，因此运行良好。</p><p>  来看运行失败的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">hierarchical_mutex <span class="hljs-title">other_mutex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_other_stuff</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">other_stuff</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">high_level_func</span>();<br>    <span class="hljs-built_in">do_other_stuff</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_b</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(other_mutex)</span></span>;<br>    <span class="hljs-built_in">other_stuff</span>();<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TD    threadB[&quot;thread_b()&quot;]    otherStuff[&quot;other_stuff()&quot;]    highLevelFunc[&quot;high_level_func()&quot;]    lowLevelFunc[&quot;low_level_func()&quot;]    doLowLevelStuff[&quot;do_low_level_stuff()&quot;]    highLevelStuff[&quot;high_level_stuff()&quot;]    doOtherStuff[&quot;do_other_stuff()&quot;]    threadB --&gt; otherStuff    otherStuff --&gt; highLevelFunc    otherStuff --&gt; doOtherStuff    highLevelFunc --&gt; lowLevelFunc    highLevelFunc --&gt; highLevelStuff    lowLevelFunc --&gt; doLowLevelStuff</code></pre><p>  线程 <code>b</code> 执行 <code>thread_b</code> 函数，初始时，线程<code>b</code> 的<code>this_thread_hierarchy_value</code> 同样为<code>ULONG_MAX</code>，即最大值。之后，<code>thread_b()</code> 经过了<code>check_for_hierarchy_violation()</code> 的检查并锁定了<code>other_mutex</code>（层次值为 <code>100</code>），使得线程<code>b</code> 的 <code>this_thread_hierarchy_value</code>值更新为当前层次互斥元的层次值 <code>100</code>。之后<code>thread_b()</code> 又调用了<code>other_stuff()</code>，其内部调用了<code>high_level_func()</code>,而 <code>high_level_func()</code>尝试锁定具有更高层次值的 <code>high_level_mutex</code>（层次值为<code>10000</code>），在进行<code>check_for_hierarchy_violation()</code> 抛出了异常，线程<code>b</code> 运行失败。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（三）</title>
    <link href="/2024/12/24/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_3/"/>
    <url>/2024/12/24/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_3/</url>
    
    <content type="html"><![CDATA[<h2 id="连接concatenation">连接[Concatenation]</h2><p>  在拓展宏时，将两个标记合并成一个标记通常很有用。而这个过程被称为<strong>标记连接</strong><code>token concatenation</code>（或称<strong>标记粘贴</strong><code>token pasting</code>），这是通过<code>##</code>预处理运算符实现的。宏进行展开时，在<code>##</code>运算符两侧的标记会被合并成为一个标记，而<code>##</code>运算符本身会被删去。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE(x, y) x ## y</span><br><br><span class="hljs-built_in">PASTE</span>(My, Class)<br><br><span class="hljs-comment">// 预处理之后</span><br>MyClass<br></code></pre></td></tr></table></figure><h3 id="合法的标记">合法的标记</h3><p>  那么 <code>##</code>两侧可以放置的合法的标记有哪些呢？一下是一些合法的标记：</p><ol type="1"><li>标识符（<code>Identifiers</code>）：合法的 <code>C/C++</code>标识符，例如变量名、函数名等；</li><li>预处理数字（<code>Preprocessing Numbers</code>）：预处理器识别的数字，包括整数和浮点数；</li><li>字符串字面量（<code>String Literals</code>）：用双引号括起来的字符串；</li><li>宏参数（<code>Macro Parameters</code>）：宏定义中使用的参数；</li><li>宏（<code>Macros</code>）：已经定义过的宏；</li><li>关键字（<code>Keywords</code>）：<code>C\C++</code> 中的关键字，比如<code>int</code>、<code>if</code>等；</li><li>操作符和分隔符（<code>Operators and Separators</code>）：如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>等；</li><li>空标记（<code>Empty Tokens</code>）：在某些情况下，空标记也是合法的，例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONCAT(a, b) a ## b</span><br><span class="hljs-built_in">CONCAT</span>(, foo)<br><br><span class="hljs-comment">// 预处理展开后：</span><br>foo<br></code></pre></td></tr></table></figure></li><li>多字符操作符（<code>Multi-Character Operators</code>）：例如<code>+=</code>、<code>-&gt;</code> 等；</li></ol><blockquote><p>并非所有的标记都可以使用 <code>##</code>操作符进行连接。如果两个标记连接后不能形成一个有效的标记，那么预处理器将不会尝试将它们合并，而是会发出警告，并输出这两个标记。这里的有效的标记就是上面罗列的合法的标记。例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONCAT(a, b) a ## b</span><br><span class="hljs-built_in">CONCAT</span>(x, +)<br></code></pre></td></tr></table></figure> <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">// g++ -E -o main.i main.cpp<br>main.cpp:3:8: error: pasting &quot;x&quot; and &quot;+&quot; does not give a valid preprocessing token<br>   3 | CONCAT(x, +)<br>     |        ^<br>main.cpp:1:22: note: in definition of macro &#x27;CONCAT&#x27;<br>   1 | #define CONCAT(a, b) a ## b<br>     |                      ^<br></code></pre></td></tr></table></figure> 可以看到，报错信息已经很显然了</p></blockquote><p>  需要注意的是， * 注释会转换为空白在宏处理之前，预处理器会将注释转换为空白字符。这就意味着不能通过连接<code>/</code> 和 <code>*</code>来创建一个注释，注释在预处理阶段就会被移除；</p><ul><li><p><code>##</code> 周围的空白 实际上可以在 <code>##</code>操作符和其操作数之间放置任意数量的空白字符，包括空格、制表符和换行符等，这类空白字符在预处理时都会被忽略；</p></li><li><p><code>##</code> 操作数和注释可以在将要被连接的参数中放置注释，因为注释会被转换为空白字符，所以最终会被<code>##</code> 处理时忽略；</p></li><li><p><code>##</code> 操作数的位置错误 <code>##</code>操作数不能出现在宏体的开头或者结尾：也就是说，<code>##</code>操作数的两侧必须有标记，当然传入宏参数时可以传入空白标记。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE(a, b) a ## b</span><br><br><span class="hljs-comment">// 正确使用，参数之间有注释</span><br><span class="hljs-built_in">PASTE</span>(a <span class="hljs-comment">/* comment */</span> , b)  <span class="hljs-comment">// 展开为 ab</span><br><br><span class="hljs-comment">// 错误使用，## 出现在宏的开始</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVALID_MACRO1 ##a  <span class="hljs-comment">// 错误，## 没有操作数</span></span><br><br><span class="hljs-comment">// 错误使用，## 出现在宏的结束</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVALID_MACRO2 a##  <span class="hljs-comment">// 错误，## 没有操作数</span></span><br></code></pre></td></tr></table></figure><h3 id="实际的例子">实际的例子</h3><p>  下面是一个运用宏连接使得代码更简洁的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">command</span>&#123;<br>    <span class="hljs-type">char</span>* name;<br>    <span class="hljs-built_in">void</span> (*function) (<span class="hljs-type">void</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">command</span> commands[] = &#123;<br>    &#123;<span class="hljs-string">&quot;quit&quot;</span>, quit_command&#125;,<br>    &#123;<span class="hljs-string">&quot;help&quot;</span>, help_command&#125;,<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>使用宏连接后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMAND(NAME) &#123;#NAME, NAME ## _command&#125;</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">command</span> commands[] = &#123;<br>    <span class="hljs-built_in">COMMAND</span>(quit),<br>    <span class="hljs-built_in">COMMAND</span>(help),<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>  这里分别使用宏<strong>字符串化</strong>和宏<strong>连接</strong>。</p><h2 id="可变参数宏variadic-macros">可变参数宏[Variadic Macros]</h2><p>  和函数一样，宏也可以在声明时接受一个可变数量的参数，语法也与函数定义相似。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> eprintf(...) fprintf(stderr, __VA_ARGS__)</span><br></code></pre></td></tr></table></figure><p>  这样的宏被称为<strong>可变参数宏</strong>。当可变参数宏被调用时，<u>所有在最后一个命名参数之后传递给宏的参数（在这个例子中，宏没有命名参数）都被视为可变参数部分</u>。这意味着，<u>包括任何逗号在内的所有标记（tokens）都被视为可变参数</u>。</p><p>  在宏体内，<code>__VA_ARGS__</code>是一个特殊的标识符，用来表示传递给宏的所有可变参数。当宏展开时，<code>__VA_ARGS__</code>会被替换为宏调用中传递的所有实际参数。在宏展开过程中，<code>__VA_ARGS__</code>将被替换为宏调用中提供的实际参数序列。这意味着，宏调用中的参数将直接替换宏定义中的<code>__VA_ARGS__</code>，包括所有的逗号和标记。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(...) printf(__VA_ARGS__)</span><br><br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><br><span class="hljs-comment">// 预处理展开后：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>); <span class="hljs-comment">// 可以看到，逗号也作为可变参数的一部分</span><br></code></pre></td></tr></table></figure><ol type="1"><li>可变参数中的宏  在可变参数被插入到宏展开中之前，它们会像普通参数一样被完全宏展开。也就是说，如果可变参数中包含宏，这些宏会在被传递到可变参数之前被展开。如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(...) printf(__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FMT <span class="hljs-string">&quot;Hello, %s!\n&quot;</span></span><br><br><span class="hljs-built_in">LOG</span>(FMT, <span class="hljs-string">&quot;world&quot;</span>);<br><br><span class="hljs-comment">// 预处理展开后：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>字符串化可变参数（#）   同样可以使用 <code>#</code>操作符来字符串化可变参数，这样可以将可变参数转化为字符串字面量。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGIFY(...) #__VA_ARGS__</span><br><br><span class="hljs-built_in">STRINGIFY</span>(some text)<br><br><span class="hljs-comment">// 预处理展开后：</span><br><span class="hljs-string">&quot;some text&quot;</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>使用 <code>##</code> 操作符   实际上，使用 <code>##</code>操作符将可变参数的首位标记与其他标记连接在一起也是允许的，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br><br><span class="hljs-built_in">PASTE_PREFIX</span>(MY_, function)<br><br><span class="hljs-comment">// 预处理展开后：</span><br>MY_function<br></code></pre></td></tr></table></figure><p>  需要注意的是，当使用 <code>##</code>连接可变参数时，如果可变参数本身为空，那么对应连接的空白标记的情况，这个时候<code>##</code> 操作符不会有任何效果。</p><p><br><br><br><br></p><p>  如果宏很复杂，那么可能希望变量参数有一个比<code>__VA_ARGS__</code>更具描述性的名称。<code>CPP</code>允许这样，作为一种扩展。可以立即在<code>...</code>前面写入一个参数名称；该名称用于变量参数。可以编写上面的<code>eprintf</code>宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> eprintf(args...) fprintf(stderr, args)</span><br></code></pre></td></tr></table></figure><p>需要注意的是，使用了拓展名之后，不能在同一个宏中同时使用拓展名和<code>__VA_ARGS__</code>。</p><p>  就如前面的例子，在一个可变参数宏中既可以存在命名参数和可变参数，如上面的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br></code></pre></td></tr></table></figure><p>但这实际上存在一个可能的问题——当此时可变参数为空时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br><br><span class="hljs-built_in">PASTE_PREFIXZ</span>(MY_, )<br></code></pre></td></tr></table></figure><p>在 <code>C++20</code> 以前，<code>PASTE_PREFIXZ(MY_, )</code> 中的<code>,</code> 被视为可变参数的一部分，所以最终展开的结果是<code>MY_,</code>，这与我们的预期不符。这个问题在 <code>C++20</code>后已经被解决了——实际上我们已经可以完全忽略可变参数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br><br><span class="hljs-built_in">PASTE_PREFIXZ</span>(MY_) <span class="hljs-comment">// 这里逗号都可以不要</span><br></code></pre></td></tr></table></figure><p>  其次，<code>C++20</code>引入了<code>__VA_OPT__</code>函数宏。此宏可能<u>只出现在可变参数宏的定义中</u>。它提供了一种条件展开机制，允许开发者根据可变参数是否存在来决定是否展开某些代码。其工作原理：</p><ol type="1"><li>条件展开<ul><li><code>__VA_OPT__</code>宏函数检查可变参数（<code>variable argument</code>）是否有任何标记（<code>tokens</code>）；</li><li>如果可变参数中包含至少一个标记，那么<code>__VA_OPT__</code>会将其参数展开为这些标记；</li><li>如果可变参数中不包含任何标记（即为空），那么<code>__VA_OPT__</code>展开为空，不会产生任何代码。</li></ul></li><li>语法<ul><li><code>__VA_OPT__</code>的使用语法是<code>__VA_OPT__(参数)</code>，其中参数是当可变参数非空时应该展开的代码；</li><li>常用：<code>__VA_OPT__(op1, op2)</code>：其中 <code>op1</code>对应可变参数中不包含任何标记时的操作，<code>op2</code>对应可变参数中包含标记时的操作。<code>op1</code>通常为空，使得当可变参数中不包含任何标记时展开为空。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(msg, ...) printf(<span class="hljs-string">&quot;Log: &quot;</span> msg <span class="hljs-string">&quot;\n&quot;</span> __VA_OPT__(, ##__VA_ARGS__) )</span><br><br><span class="hljs-comment">// 调用示例</span><br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;This is a message&quot;</span>);<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;This is a message&quot;</span>, <span class="hljs-string">&quot; with additional info&quot;</span>);<br><br><span class="hljs-comment">// 预处理之后：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Log: This is a message\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Log: This is a message, with additional info\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中： -<code>LOG</code>宏定义了一个可变参数宏，其中使用了<code>__VA_OPT__</code>；-当只有<code>msg</code>参数被提供时，<code>__VA_ARGS__</code>为空，<code>__VA_OPT__(, ##__VA_ARGS__)</code>展开为空，因此没有额外的代码被添加；-当提供了额外的参数时，<code>__VA_ARGS__</code>非空，<code>__VA_OPT__(, ##__VA_ARGS__)</code>展开为,<code>##__VA_ARGS__</code>，这允许<code>printf</code>函数接受额外的参数。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Cpp</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（二）</title>
    <link href="/2024/11/20/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_2/"/>
    <url>/2024/11/20/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_2/</url>
    
    <content type="html"><![CDATA[<h2 id="一宏参数">一、宏参数</h2><p>  和真正的函数一样，类函数宏也<strong>可以接受参数</strong>。类函数宏需要参数时，你需要将参数插入圆括号<code>()</code>中，这和调用函数时一样(函数声明和定义时需要指明参数类型，宏是文本替换，所以不需要提供参数类型信息)。需要注意的是，宏参数须为有效的<code>C/C++</code>标识符，并且在<strong>存在多个参数时使用逗号隔开，以及可选的空格</strong>。</p><h3 id="调用宏的方式">1.1 调用宏的方式</h3><p>  当想要使用一个带有参数的宏时，宏名称后接一对圆括号<code>()</code>，并且<strong>在括号内插入实际的参数列表，参数列表用逗号隔开</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) ((a) &gt; (b)? (a): (b))</span><br><br><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="宏调用可以跨多行">1.2 宏调用可以跨多行</h3><p>  宏的调用不必限制在源文件的单行内，它<strong>可以跨越多行</strong>。这意味着你可以在调用宏时，在参数列表中使用换行符，以提高代码的可读性。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<br>    a + b,<br>    c + d<br>);<br></code></pre></td></tr></table></figure><p>因为上一节讲过，所有宏都会被展开成源代码中的一行。</p><h3 id="参数数量必须匹配">1.3 参数数量必须匹配</h3><p>  当然，在调用宏时<strong>提供的参数数量必须与宏定义中的参数数量相匹配</strong>。如果宏定义了两个参数，调用时也必须提供两个参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><h3 id="宏展开时参数的替换">1.4 宏展开时参数的替换</h3><p>  当宏被展开时，<strong>宏体</strong>中的每个参数都会被对应的实际参数替换。这里的<strong>替换</strong>指的是<u>将宏定义中的参数名称替换为实际参数的代码</u>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) ((a) &gt; (b)? (a): (b))</span><br><br><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = ((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><h3 id="参数的使用是可选的">1.5 参数的使用是可选的</h3><p>  <strong>宏中定义的参数的使用是可选的</strong>，宏体定义的参数不一定要在宏体中使用。可以定义一个参数，但在宏体中不使用它，或者只使用部分参数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_LOG(x, y) printf(<span class="hljs-string">&quot;Value of x: %d\n&quot;</span>, x)</span><br></code></pre></td></tr></table></figure><h3 id="宏调用时参数的处理规则">1.6 宏调用时参数的处理规则</h3><h4 id="参数前后的空白字符被丢弃">1. 参数前后的空白字符被丢弃</h4><p>  在宏调用中，每个参数前后的空白字符（空格、制表符等）都会被丢弃。这意味着，无论实际参数前后有多少空白字符，它们都不会出现在宏展开后的代码中。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(    <span class="hljs-number">2</span>    ,    <span class="hljs-number">3</span>    );<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = ((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>可以看到，参数 <code>2</code>和<code>3</code>前后的空白字符都被丢弃。</p><h4 id="参数内部的空白字符被压缩为单个空格">2.参数内部的空白字符被压缩为单个空格</h4><p>  在参数内部，所有的空白字符（包括空格、制表符等）都会被压缩为单个空格。这意味着，无论参数内部有多少连续的空白字符，它们都会被替换为一个空格。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span> +    <span class="hljs-number">4</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = ((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span> + <span class="hljs-number">4</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span> + <span class="hljs-number">4</span>));<br></code></pre></td></tr></table></figure><p>参数<code>3 +    4</code>中的多个空白字符被压缩成了一个空格。</p><h4 id="参数内的括号必须平衡">3. 参数内的括号必须平衡</h4><p>  在参数内部，如果使用了圆括号，那么这些圆括号必须平衡（即每对开括号(必须有对应的闭括号)）。<u>在平衡的圆括号内部的逗号不会导致参数的结束，简单理解就是圆括号中的逗号不会将其分隔成不同参数</u>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = (((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) &gt; (<span class="hljs-number">3</span>)? ((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>且不论上述宏展开后的代码是否合法（实际上宏展开也不会进行语法检查），参数<code>(2, 3)</code>并没有被分隔成两个参数<code>(2</code> 和 <code>3)</code>。所以说，圆括号务必要平衡。</p><h4 id="方括号和花括号不需要平衡">4. 方括号和花括号不需要平衡</h4><p>  对于方括号<code>[]</code>和花括号<code>&#123;&#125;</code>，不需要平衡，其内部的逗号仍然会被视为参数分隔符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">3</span>); <span class="hljs-comment">// 三个参数 [2、3] 和 3</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-number">3</span>); <span class="hljs-comment">// 三个参数 &#123;2、3&#125; 和 3</span><br></code></pre></td></tr></table></figure><p>这里<strong>实际上是无法进行宏展开的</strong>，会导致编译错误，因为宏定义时只接受两个参数，而这里提供了三个参数。</p><h3 id="宏参数的展开规则">1.7 宏参数的展开规则</h3><ol type="1"><li><p>宏参数的完全展开  <u>在宏体中替换参数之前，所有传递给宏的实际参数都会先进行完全的宏展开</u>。这意味着，如果实际参数本身是一个宏，或者包含宏，那么这些宏会首先被展开。</p></li><li><p>替换后的再次扫描  替换参数到宏体之后，整个宏体（包括替换后的参数）会再次被扫描，以查找是否有更多的宏需要展开。这个过程会持续进行，直到没有更多的宏可以展开。</p></li></ol><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>第一次，参数进行展开： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>), <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></p><p>第二次，替换后的再次扫描： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = ((((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>))) &gt; (<span class="hljs-number">3</span>)? (((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>))): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure></p><p>事实上，你甚至在为宏传递空参数，例如： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = (() &gt; (<span class="hljs-number">3</span>)? (): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure></p><p>但是在传空参数时仍然要确保参数的匹配。</p><p>  需要注意的是：出现在<strong>字符串中的宏参数不会被它们相应的实际参数替换</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo(x) x, <span class="hljs-string">&quot;x&quot;</span></span><br><br><span class="hljs-comment">// 实际调用</span><br><span class="hljs-built_in">foo</span>(bar)<br><br><span class="hljs-comment">// 预处理展开后</span><br>bar, <span class="hljs-string">&quot;x&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>到这里，你一定会疑惑，为什么我们在宏定义时，宏体中的参数都会包裹在一对圆括号内</p></blockquote><h3 id="宏体参数用圆括号包裹的原因">1.8 宏体参数用圆括号包裹的原因</h3><h4 id="操作符优先级">1. 操作符优先级：</h4><p>  在C/C++中，宏参数可能会与宏体中的其他代码一起参与运算。如果不使用括号，可能会因为操作符优先级的问题导致宏的展开结果与预期不符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) x * x</span><br></code></pre></td></tr></table></figure><p>  如果你使用<code>SQUARE(a + b)</code>，宏会展开为<code>a + b * a + b</code>，这显然不是我们想要的结果，因为按照乘法优先于加法的规则，它实际上变成了<code>a + (b * a) + b</code>。正确的结果应该是<code>(a + b) * (a + b)</code>。</p><h4 id="使用括号可以确保参数作为一个整体被处理">2.使用括号可以确保参数作为一个整体被处理：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) (x) * (x)</span><br></code></pre></td></tr></table></figure><p>  这样，<code>SQUARE(a + b)</code>会正确展开为<code>(a + b) * (a + b)</code>。</p><h4 id="避免宏参数为空">3. 避免宏参数为空：</h4><p>  如果宏的参数可能为空（例如，在宏定义中使用<code>##</code>运算符进行连接时），不使用括号可能会导致编译错误。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EMPTY()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GLUE(x, y) x ## y</span><br><br><span class="hljs-built_in">GLUE</span>(EMPTY, <span class="hljs-type">int</span>) var; <span class="hljs-comment">// 这将尝试定义一个名为&quot;int&quot;的变量，而不是&quot;Emptyint&quot;</span><br></code></pre></td></tr></table></figure><p>  如果<code>EMPTY</code>宏没有括号，<code>GLUE(EMPTY, int)</code>将尝试将<code>EMPTY</code>和<code>int</code>连接起来，而不是将<code>EMPTY()</code>作为一个整体与<code>int</code>连接。</p><h4 id="参数可能包含多个标记">4. 参数可能包含多个标记：</h4><p>  如果宏参数本身是一个复合表达式或多个标记，那么使用括号可以确保整个表达式被正确处理。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE_AND_INCREMENT(x) ((x) * (x)) + 1</span><br></code></pre></td></tr></table></figure><p>  这里，<code>(x)</code>确保了<code>x</code>的整个表达式被乘以自身，然后再加<code>1</code>。</p><h4 id="提高代码的可读性和一致性">5. 提高代码的可读性和一致性：</h4><p>  使用括号可以使宏的定义更加清晰，让阅读代码的人更容易理解宏的意图和行为。</p><h2 id="二字符串化">二、字符串化</h2><p>  预处理器中的字符串化（<code>Stringizing</code>）操作。这是一种将宏参数转换为字符串常量的技术。有时可能希望将宏参数转换为字符串常量。<u>在字符串常量中，参数不会被替换，但是可以使用<code>#</code>预处理操作符来实现这一点</u>。</p><h3 id="操作符的使用">2.1 #操作符的使用</h3><p>  当宏参数前面有一个<code>#</code>操作符时，预处理器会用实际参数的文本内容替换它，并将其转换为字符串常量。这与普通的参数替换不同，因为参数不会首先被宏展开。</p><p>  字符串化操作<u>不会在参数替换之前对参数进行宏展开</u>。这意味着如果参数是一个宏，它不会被展开，而是直接将其名称作为字符串插入。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING hello</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGFY(Argu) #Argu</span><br><br><span class="hljs-built_in">STRINGFY</span>(STRING)<br></code></pre></td></tr></table></figure><p>预处理展开之后： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;STRING&quot;</span><br></code></pre></td></tr></table></figure>可以看到，宏<code>STRINGFY</code>的参数也是一个宏<code>STRING</code>，但并没有被展开为<code>hello</code>，而是直接将其名称字符串化为了字符串常量<code>"STRING"</code>。</p><p>  不能直接将参数与周围的文本组合在一起并一次性字符串化。相反，你可以编写一系列相邻的字符串常量和字符串化的参数。预处理器会将字符串化的参数替换为字符串常量，然后，编译器会将所有相邻的字符串常量合并为一个长字符串。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> WARN_IF(EXP) \</span><br><span class="hljs-meta">do &#123; <span class="hljs-keyword">if</span> (EXP) \</span><br><span class="hljs-meta">        fprintf (stderr, <span class="hljs-string">&quot;Warning: &quot;</span> #EXP <span class="hljs-string">&quot;\n&quot;</span>); &#125; \</span><br><span class="hljs-meta">while (0)</span><br><span class="hljs-built_in">WARN_IF</span> (x == <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>预处理器展开后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span> &#123; <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) \<br>    <span class="hljs-built_in">fprintf</span> (stderr, <span class="hljs-string">&quot;Warning: &quot;</span> <span class="hljs-string">&quot;x == 0&quot;</span> <span class="hljs-string">&quot;\n&quot;</span>); \<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>注意，这里的<code>\</code>表示行间是连接的，因为宏展开会成一行，这里为了方便，增加了换行。可以看到，<code>EXP</code>的参数被替换为 <code>if</code> 语句中的条件参数和 <code>fprintf</code>参数中的 <code>string</code> 参数。<u>如果 <code>x</code>是一个宏，它将在 <code>If</code>语句中展开，但不会在字符串中展开</u>。后面的几个字符串常量<code>"Warning: " "x == 0" "\n"</code>会在编译器的帮助下合并成一个字符串常量。</p><blockquote><p>这里其实还提到了 <code>do...while(0)</code>循环的使用，这是一种技巧，将在后续章节探讨。</p></blockquote><p>  可见，字符串化不仅仅是在宏参数周围添加双引号那么简单。预处理器会进行额外的处理，以确保生成的字符串常量是有效的，并且包含正确的内容。</p><h3 id="宏参数字符串化的细节处理">2.2 宏参数字符串化的细节处理</h3><h4 id="预处理器对引号和反斜杠的处理">1.预处理器对引号和反斜杠的处理</h4><p>  当宏参数中包含字符串常量时，预处理器会对其进行转义处理。这意味着，如果宏参数中包含双引号或反斜杠，预处理器会在它们前面添加反斜杠来进行转义。这样做的目的是为了确保生成的字符串常量在<code>C/C++</code>语言中是有效的。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGFY(Argu) #Argu</span><br><br><span class="hljs-built_in">STRINGFY</span>(<span class="hljs-string">&quot;hello\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>预处理器展开后： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;\&quot;hello\\n\&quot;&quot;</span><br></code></pre></td></tr></table></figure></p><h4 id="非字符串或字符常量中的反斜杠不加倍">2.非字符串或字符常量中的反斜杠不加倍</h4><p>  如果反斜杠不在字符串或字符常量中，它们不会被加倍。例如，<code>\n</code>单独字符串化时，结果就是<code>"\n"</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGFY(Argu) #Argu</span><br><br><span class="hljs-built_in">STRINGFY</span>(\n)<br></code></pre></td></tr></table></figure><p>预处理器展开后： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;\n&quot;</span><br></code></pre></td></tr></table></figure></p><h4 id="字符串化中的空白处理">3. 字符串化中的空白处理</h4><p>  在字符串化过程中，宏参数中的所有前导和尾随空白都会被忽略。文本中的任何空白序列（空格、制表符等）在字符串化结果中会被转换为单个空格。其实也是一种特殊的宏参数处理。</p><h4 id="无法将宏参数转换为字符常量">4. 无法将宏参数转换为字符常量</h4><p>  没有办法将宏参数直接转换为字符常量。这是因为字符常量在<code>C/C++</code>语言中是用单引号括起来的单个字符，而字符串化操作是将整个宏参数转换为双引号括起来的字符串常量。</p><h3 id="如何字符串化宏参数的展开">2.3 如何字符串化宏参数的展开</h3><p>  如果要将<strong>宏参数展开后的结果转换成字符串常量</strong>，则需要使用<strong>两级宏</strong>（即<strong>嵌套宏</strong>）来实现。这是因为在预处理阶段，<u>宏参数首先被展开，然后才进行字符串化</u>。如果直接在宏中使用<code>#</code>操作符来字符串化宏参数，那么字符串化的是宏参数本身，而不是它展开后的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xstr(s) str(s)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> str(s) #s</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo 4</span><br><br><span class="hljs-built_in">xstr</span> (foo)<br></code></pre></td></tr></table></figure><p>第一次展开： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">xstr</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// 第一次展开并非字符串化，故参数会展开</span><br></code></pre></td></tr></table></figure></p><p>第二次展开： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">str</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// 第二次展开是 xstr 展开</span><br></code></pre></td></tr></table></figure></p><p>然后字符串化： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;4&quot;</span> <span class="hljs-comment">// 最后是字符串化</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Cpp</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（一）</title>
    <link href="/2024/11/18/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_1/"/>
    <url>/2024/11/18/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_1/</url>
    
    <content type="html"><![CDATA[<h3 id="宏是什么">宏是什么？</h3><p>  <strong>宏</strong>(<code>Macros</code>)是一段代码片段，每个<strong>宏</strong>被赋予了一个名称。<strong>无论何时使用该名称，都将由宏的内容替换</strong>（其实就是文本替换）。宏有两种——<strong>类对象宏(<code>Object-like Macros</code>)</strong>和<strong>类函数宏(<code>Function-like Macros</code>)</strong>。它们的差异主要体现在使用时，使用<strong>类对象宏</strong>时类似于数据对象，使用<strong>类函数宏</strong>时类似于函数调用。</p><p><span class="math display">\[宏\begin{cases}类对象宏 \\\\类函数宏\end{cases}\]</span></p><h3 id="类对象宏object-like-macros">类对象宏(Object-like Macros)</h3><p>  <strong>类对象宏</strong>其实就是一个简单的<strong>标识符</strong>，其在代码中被使用之处会被其所指的代码片段给替换。之所以将其称为<strong>类对象宏</strong>，是因为在代码中使用<strong>类对象宏</strong>时就像在使用普通的数据对象一样。通常的<u>使用场景是给数值常量赋予符号名称</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 示例1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14</span><br></code></pre></td></tr></table></figure><p>  <u>在<code>C/C++</code>中，宏是通过预处理指令<code>#define</code>来创建的</u>。这个指令告诉预处理器定义一个新的宏（预处理器是C/C++编译过程中的一个阶段，负责处理源代码中的预处理指令，如宏定义、文件包含和条件编译等）。</p><p>  <code>#define</code>后面紧跟的是宏的<strong>名称</strong>。宏的名称<strong>通常以大写字母表示</strong>，以区分于变量和其他标识符，这是一种约定俗成的命名习惯，有助于提高代码的可读性。</p><p>  宏名称之后是宏的<strong>替换列表(replacementlist)</strong>，也就是<u>当宏被使用时，预处理器将宏名称替换为这个列表中的代码</u>。这个替换列表有时被称为宏的“<strong>体</strong>”(<code>body</code>)、“<strong>展开</strong>”(<code>expansion</code>)。</p><blockquote><p>需要注意得是，宏定义后没有分号！本质上宏是一种预编译指令，并不是<code>C/C++</code>得一条语句，所以没有分号。</p></blockquote><p>  示例1中定义了一个名为 <code>PI</code>的宏表示圆周率，其对应的<strong>宏体</strong>为我们希望圆周率所取得的数值<code>3.14</code>。如果在 <code>define</code>语句之后，某个代码位置使用了这个宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> perimeter = <span class="hljs-number">2</span>*PI;<br></code></pre></td></tr></table></figure><p>然后 <code>C/C++</code> 预处理器将识别并展开宏 <code>PI</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> perimeter = <span class="hljs-number">2</span>*<span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><p>  通常，<u>宏的主体结束于 <code>#define</code>行的末尾</u>。如果需要，可以使用<strong>反斜杠</strong><code>\</code><strong>换行</strong>将定义继续到多行。然而，<u>当宏被展开时，它们都会出现在一行中</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUMBERS 1, \</span><br><span class="hljs-meta">                2, \</span><br><span class="hljs-meta">                3</span><br><br><span class="hljs-type">int</span> nums[] = &#123;NUMBERS&#125;;<br><br><span class="hljs-comment">// 预处理展开后：</span><br><br><span class="hljs-type">int</span> nums[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>这里官方文档说：因为预处理后宏会变成一行，那么报错信息提供的行号和我们实际所看到的行号就存在偏差。可能因为时间原因，这个问题已经不存在了：</p><p><img src="/img/in_posts/Macros/code1.png" alt="错误代码" />这段代码里，<code>return</code> 语句后没写分号。查看报错信息： <imgsrc="/img/in_posts/Macros/code1_err_info.png" alt="报错信息" />可以看到，报错信息里面行号是正常显示的，这个问题可以忽略。</p></blockquote><p>  在<code>C/C++</code>语言中定义宏时，宏体可以包含任何内容，只要这些内容能够分解成有效的<strong>预处理标记</strong>（<code>preprocessing tokens</code>）。这里的“预处理标记”指的是<u>预处理器能够识别的基本单位，比如关键字、标识符、字面量、运算符等</u>。&gt; 什么意思？如下： &gt; <strong>无限制的内容</strong> &gt;宏体中可以放入任何字符序列，<u>预处理器不会对宏体的内容做语法检查，它只负责将宏名替换为宏体的内容</u>；&gt; 正因如此，宏体中的代码片段甚至不必看起来是 <code>C/C++</code>的代码，但是编译结束可能会投来编译错误.😂</p><p>  <code>C/C++</code>预处理器<strong>按顺序扫描程序</strong>。宏定义在编写它们的地方生效，<u>也即是说在其定义之处之后的作用域内有效</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = N;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 3</span><br><span class="hljs-type">int</span> b = N;<br></code></pre></td></tr></table></figure><p>预处理之后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = N;<br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>这里就出错了，预处理器按顺序扫描到第一个语句时，<code>N</code>并没有被定义，而在其后方才被定义为宏，于是只有<code>b</code>的赋值语句中<code>N</code> 被正确展开成了 <code>3</code>。</p><p>  <code>C/C++</code>预处理器在处理宏时的展开过程。<u>当宏体中出现宏的调用（即宏名的使用）时，预处理器会将展开后的宏体中的宏继续展开</u>。这个过程是<strong>递归</strong>的，直到所有的宏都被替换为它们的值或者代码片段。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABLESIZE BUFFERSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 1024</span><br></code></pre></td></tr></table></figure><p>那么实际上，<code>TABLESIZE</code> 首先被展开成<code>BUFSIZE</code>，然后 <code>BUFSIZE</code> 又被展开为<code>4</code>，所以最终的效果是使用 <code>TABLESIZE</code>的地方都被展开成了 <code>4</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">TABLESIZE <br>    -&gt; BUFSIZE<br>    -&gt; <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>  注意，在定义 <code>TABLESIZE</code> 时没有定义<code>BUFSIZE</code>。<code>TABLESIZE</code>的<code>#define</code>完全使用指定的展开式，因为不会进行语法检查，并且不检查它是否也包含宏名称。只有当您使用<code>TABLESIZE</code>时，才会扫描其展开的结果以查找更多的宏名称，因为使用<code>TABLESIZE</code> 之处也处于 <code>BUFSIZE</code>作用域之内。这也说明了，宏指令的位置与最终展开的结果相关，预处理最终将会使用当前生效的宏进行展开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABLESIZE BUFSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> BUFSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 37</span><br></code></pre></td></tr></table></figure><p>这个示例中，<code>TABLESIZE</code> 最终被展开为了<code>37</code>。</p><p>  还有一种情况：如果宏体中包含自身的宏名称(直接或通过中间宏)，<u>则在检查更多宏时不再展开。这可以防止无限递归</u>。下面是一个例子来说明这种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO FOO</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>FOO</code> 宏被定义为它自己。当预处理器遇到<code>FOO</code> 时，它会尝试展开 <code>FOO</code>，但发现<code>FOO</code> 的定义就是它自己，所以预处理器不会再次展开<code>FOO</code>，避免了无限递归。</p><p>另一个更复杂的例子，涉及中间宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BAR FOO</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO BAR</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>FOO</code> 被定义为 <code>BAR</code>，而<code>BAR</code> 被定义为 <code>FOO</code>。如果预处理器尝试展开<code>FOO</code>，它会被替换为 <code>BAR</code>，然后 <code>BAR</code>又会尝试展开为 <code>FOO</code>，但此时预处理器已经知道 <code>FOO</code>会展开为 <code>BAR</code>，所以它不会再次展开<code>FOO</code>，避免了无限递归。</p><p>在这两种情况下，预处理器都会停止进一步展开宏，以防止无限递归的发生。这种自我引用的宏定义通常不是有意为之的，因为它们不会产生有用的结果，但它们确实展示了预处理器如何处理宏的递归展开，这部分将在后续<code>自引用宏章节</code> 介绍。</p><h3 id="类函数宏function-like-macros">类函数宏(Function-likeMacros)</h3><p>  实际上，还可以定义<strong>看起来像函数调用的宏</strong>。这些被称为<strong>类函数宏</strong>。要定义一个类似函数的宏，同样使用<code>#define</code>指令，但在<u>宏名称后紧接一对括号</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lang_init()  c_init()</span><br><br><span class="hljs-comment">// 预处理后</span><br><span class="hljs-built_in">lang_init</span>()<br>     -&gt; <span class="hljs-built_in">c_init</span>()<br></code></pre></td></tr></table></figure><p>当定义了一个类函数宏时，只有当这个宏的名字后面紧跟着一对括号时，它才会被展开。<u>如果宏的名字后面没有括号，那么它就不会被展开，而是保持原样</u>。这在存在同名的<strong>函数</strong>和<strong>类函数宏</strong>时，希望调用真实函数而不是宏时进行区分很有用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo() <span class="hljs-comment">/* optimized inline version */</span></span><br>...<br><span class="hljs-built_in">foo</span>();<br>funcptr = foo;<br></code></pre></td></tr></table></figure><p>这里对 <code>foo()</code> 的调用将使用<strong>宏</strong>，而函数指针<code>funcptr</code> 获取的是<strong>函数</strong><code>foo</code>的地址。但是这里如果将 <code>foo()</code> 进行展开将会出现语法错误……</p><p>  如果在宏定义中的宏名称和括号之间放置空格，则不是类函数宏，而是定义了一个类对象宏，其扩展恰好以一对括号开始：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lang_init ()  c_init()</span><br><br><span class="hljs-comment">// 预处理后</span><br><span class="hljs-built_in">lang_init</span>()<br>     -&gt; ()  <span class="hljs-built_in">c_init</span>()()<br></code></pre></td></tr></table></figure><p>需要注意。</p><!-- [官方文档](https://gcc.gnu.org/onlinedocs/cpp/Macros.html) -->]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Cpp</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试博客功能</title>
    <link href="/2024/11/16/Test/test/"/>
    <url>/2024/11/16/Test/test/</url>
    
    <content type="html"><![CDATA[<h1 id="线性代数二次型">线性代数——二次型</h1><h2id="一二次型的定义及其矩阵表达式">一、二次型的定义及其矩阵表达式</h2><p>  <span class="math inline">\(n\)</span> 元变量 <spanclass="math inline">\(x_1\)</span>，<spanclass="math inline">\(x_2\)</span>，...，<spanclass="math inline">\(x_n\)</span> 的二次齐次多项式</p><p><span class="math display">\[f(x_1, x_2, ..., x_n) =a_{11}x_1^2+2a_{12}x_1x_2+...+2a_{1n}x_1x_n\\\\+a_{22}x_2^2+2a_{23}x_2x_3+...+2a_{2n}x_2x_n\\\\+...+a_{nm}x_n^2\]</span></p><p>称为 <span class="math inline">\(n\)</span><strong>元二次型</strong>，简称<strong>二次型</strong>.</p><p>  这里只介绍系数 <span class="math inline">\(a_{ij} \in R(i \le j;i,j = 1, 2, ..., n)\)</span>的情况，称此二次型 <spanclass="math inline">\(f\)</span> 为<strong>实二次型</strong>.</p><p>  因为 <span class="math inline">\(x_ix_j = x_jx_i\)</span>，于是令<span class="math inline">\(a_{ij} = a_{ji}(i,j = 1, 2, ...,n)\)</span>，则 <span class="math inline">\(2a_{ij}x_ix_j =a_{ij}x_ix_j+a_{ji}x_jx_i\)</span>，于是令</p><p><span class="math display">\[\A = \begin{pmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\\\a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\end{pmatrix}\]</span></p><p><span class="math display">\[x = \begin{pmatrix}x_{1} \\\\x_{2} \\\\\vdots \\\\x_{n} \\\\\end{pmatrix}\]</span></p><p>则二次型可以表示为</p><p><span class="math display">\[f(x) = x^TAx\]</span></p><p>其中，<strong>实对称矩阵</strong><spanclass="math inline">\(A\)</span>称为<strong>二次型</strong><spanclass="math inline">\(f(x)\)</span><strong>的矩阵</strong>. 这里 <spanclass="math inline">\(A\)</span> 是一个对称矩阵，<spanclass="math inline">\(A_{ij} = (a_{ij}), a_{ij} =a_{ji}\)</span>，即满足 <span class="math inline">\(A^T = A\)</span>.实际上二次型可以有多种写法，如： <span class="math display">\[f(x) =x_1^2+x_2^2+4x_1x_2\]</span> 或 <span class="math display">\[f(x) =x_1^2+x_2^2+1x_1x_2+3x_2x_1\]</span></p><p>于是对应的矩阵 <span class="math inline">\(A\)</span> 分别为： <spanclass="math display">\[\A = \begin{pmatrix}1 &amp; 2  \\\\2 &amp; 1 \\\\\end{pmatrix}\]</span></p><p>和</p><p><span class="math display">\[\A = \begin{pmatrix}1 &amp; 1  \\\\3 &amp; 1 \\\\\end{pmatrix}\]</span></p><p>而这里作了规定，<strong>二次型的矩阵必须为对称矩阵</strong>，那么如此代表二次型的矩阵就是<strong>唯一</strong>的了.</p><h2id="二合同变换二次型的合同标准型规范型">二、合同变换，二次型的合同标准型、规范型</h2><h3 id="线性变换的定义">1.线性变换的定义</h3><p>  对于 <span class="math inline">\(n\)</span>元二次型 <spanclass="math inline">\(f(x_1, x_2, ..., x_n)\)</span>，若令</p><p><span class="math display">\[ \left\{\begin{aligned}x_1 &amp;= c_{11}y_1 + c_{12}y_2 + \cdots + c_{1n}y_n \\x_2 &amp;= c_{21}y_1 + c_{22}y_2 + \cdots + c_{2n}y_n \\&amp;\vdots \\x_n &amp;= c_{n1}y_1 + c_{n2}y_2 + \cdots + c_{nn}y_n\end{aligned}\right.\]</span></p><p>记 <span class="math display">\[x = \begin{pmatrix}x_{1} \\\\x_{2} \\\\\vdots \\\\x_{n} \\\\\end{pmatrix}\]</span></p><p><span class="math display">\[\C = \begin{pmatrix}c_{11} &amp; c_{12} &amp; \cdots &amp; c_{1n} \\\\c_{21} &amp; c_{22} &amp; \cdots &amp; c_{2n} \\\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\c_{n1} &amp; c_{n2} &amp; \cdots &amp; c_{nn}\end{pmatrix}\]</span></p><p><span class="math display">\[y = \begin{pmatrix}y_{1} \\\\y_{2} \\\\\vdots \\\\y_{n} \\\\\end{pmatrix}\]</span></p><p>则，上式可以写为：</p><p><span class="math display">\[x = Cy\]</span>上述变换称为<strong>线性变换</strong>，若线性变换的系数矩阵<spanclass="math inline">\(C\)</span>可逆，即 <span class="math inline">\(|C|\ne 0\)</span>，则称为<strong>可逆线性变换</strong>. 现给出： <spanclass="math display">\[f(x) = x^TAx\]</span> 令 <spanclass="math inline">\(x = Cy\)</span>，则 <spanclass="math display">\[f(x) = (Cy)^TA(Cy) = y^T(C^TAC)y\]</span> 记<span class="math inline">\(B = C^TAC\)</span>，则 <spanclass="math display">\[f(x) = y^TBy = g(y)\]</span>显然，这又是一个新的二次型：即二次型 <spanclass="math inline">\(f(x)=x^TAx\)</span>通过线性变换 <spanclass="math inline">\(x=Cy\)</span> 得到了一个新的二次型 <spanclass="math inline">\(g(y) = y^TBy\)</span></p><figure class="highlight c++"><figcaption><span>&#123;#测试代码块功能&#125; &#123;:linenos&#125; &#123;:highlight</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试链接其他帖子 <ahref="https://hijackiee.github.io/2024/12/26/Concurrency/c++%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B1%82%E6%AC%A1%E9%94%81/">层次锁</a></p><p><img src="/img/in_posts/blog_start/changli.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
      <tag>latex</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
